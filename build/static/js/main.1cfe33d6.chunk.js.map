{"version":3,"sources":["preprocessing/preprocess_eaf.js","preprocessing/eaf_utils.js","preprocessing/pfsx_utils.js","preprocessing/helper_functions.js","preprocessing/flex_utils.js","Stories/Story/Sidebar/Title.jsx","Stories/Story/Sidebar/Video.jsx","Stories/Story/Sidebar/Minibar/Info/SpeakerInfo.jsx","Stories/Story/Sidebar/Minibar/Info/Metadata.jsx","Stories/Story/Sidebar/Minibar/Info/Info.jsx","Stories/Story/Sidebar/Minibar/Settings/TierCheckboxList.jsx","Stories/Story/Sidebar/Minibar/Settings/Settings.jsx","Stories/Story/Sidebar/Minibar/Minibar.jsx","Stories/Story/Sidebar/Sidebar.jsx","Stories/Story/Display/Sentence.jsx","Stories/Story/Display/Untimed.jsx","Stories/Story/Display/Apagar.jsx","Stories/Story/Display/Timed.jsx","Stories/Story/Display/CenterPanel.jsx","js/txt_sync.js","Stories/Story/Story.jsx","Stories/Story/Display/Insert.jsx","Stories/NotFound.jsx","Stories/Stories.jsx","Stories/Story/Display/Export.jsx","components/NewProject.jsx","components/Home.jsx","App.jsx","reportWebVitals.js","index.js"],"names":["fs","require","getAlignableAnnotationStartSlot","getAlignableAnnotationEndSlot","getDocID","getNonemptyTiers","getParentTierName","getTierName","isTierSubdivided","getAnnotationValue","getAnnotations","getAnnotationID","getAnnotationIDMap","getDocTimeslotsMap","getTierSpeakerName","getTierChildrenMap","getTierLanguage","pfsxUtils","helper","scaledSlot","slotIn","parentStart","tierEnd","latestEnd","parentLen","childLen","slot","Math","floor","assignSlots","anotID","tiersToConstraints","annotationChildren","annotationsFromIDs","timeslots","startSlots","endSlots","assignSlotsHelper","stretchSlots","parentStartSlot","latestEndSlot","depTierName","hasOwnProperty","slotNum","prevTimeslot","maybeGaps","depAnotIDs","depAnotID","startTimeslot","max","prevStretch","length","parentEnd","origStart","newStart","scaledEnd","module","exports","preprocess","adocIn","pfsxIn","xmlFileName","callback","storyID","jsonOut","improveElanIndexData","metadata","tiers","indepTiers","filter","tier","tierIDsFromNames","i","newID","toString","tierName","name","subdivided","typesToConstraints","linguisticTypes","LINGUISTIC_TYPE","lingType","lingTypeID","$","LINGUISTIC_TYPE_ID","constraintName","CONSTRAINTS","LINGUISTIC_TYPE_REF","untimedTiers","childTierName","annotation","childAnnotationID","parentAnnotationID","REF_ANNOTATION","ANNOTATION_REF","push","childIDs","sortedChildIDs","constraint","prev","cur","find","a","PREVIOUS_ANNOTATION","console","log","tierChildren","parentTier","childTierNames","timeSubdivChildTiers","n","childTier","childTierAnots","parentAnot","prevSlot","endSlot","curID","parentAnotID","inclChildTiers","parentEndSlot","parentStartMs","parentEndMs","anot","startSlot","startsWithin","endsWithin","sort","id1","id2","a1","a2","splice","prevIndex","prevID","prevAnot","nextID","nextAnot","nextSlot","newAnot","anotDescendants","indepTier","indepAnot","indepAnotID","depTiersAnots","pendingParentIDs","parentID","shift","concat","garbageTierNames","getHiddenTiers","garbageTierIDs","garbageTierName","tierNameOrder","getTierOrder","tierIDOrder","spkrID","tierID","anotStartSlots","anotEndSlots","sentenceJson","parseInt","depTierJson","depAnot","values","dependents","orderedDependents","t","includes","sentences","s1","s2","start_time_ms","writeFile","JSON","stringify","parentName","getDescendants","ancestor","children","descendants","child","getTierDependentsMap","tierDependents","indepTierName","slotIDDiff","slot1","slot2","slice","isTierAlignable","ALIGNABLE_ANNOTATION","TIER_ID","PARENT_REF","ANNOTATION","getTimeslotSet","Set","annotations","map","allSlots","add","isAnnotationAlignable","unwrapAnnotation","getAnnotationTimedAncestor","currentannotation","getInnerAnnotationStartSlot","getInnerAnnotationEndSlot","getInnerAnnotationID","innerAnnotation","ANNOTATION_ID","TIME_SLOT_REF1","TIME_SLOT_REF2","adoc","properties","HEADER","PROPERTY","property","NAME","urn","_","substring","lastIndexOf","timeslotsIn","TIME_ORDER","TIME_SLOT","TIME_SLOT_ID","TIME_VALUE","TIER","getTierTimeslotsMap","tierTimeslots","slotsSet","maybeDepTier","sortedSlots","Array","from","slotRanks","slotIndex","currentTier","getTierAlignedAncestor","PARTICIPANT","LANG_REF","ANNOTATION_VALUE","getAnnotationStartSlot","getAnnotationEndSlot","getPrefList","listName","jsonData","prefLists","prefList","getFilenameFromPath","path","begin","String","getTitleFromFilename","filename","getMetadataFromIndex","index","parse","readFileSync","date","Date","prettyDate","getMonth","getDate","getFullYear","speakers","linkedMediaPaths","mediaDescriptors","mediaDesc","getDocumentFirstSentence","doc","getParagraphSentences","getDocumentParagraphs","paragraphs","wrappedParagraphs","paragraph","wrappedParagraph","phrases","word","phrase","sentence","getSentenceTextItemIfExists","item","gloss","type","getSentenceStartTime","sentenceProperties","timeString","getSentenceWords","words","wordList","getFreeGlossValue","freeGloss","getDocumentSourceLang","firstSentence","firstWord","lang","documentHasTimestamps","getSentenceTextIfNoWords","textItem","getSentenceFreeGlosses","freeGlosses","rawFreeGlosses","getSentenceEndTime","getSentenceSpeaker","speaker","getWordMorphs","morphemes","morph","getWordValue","getMorphTiers","getMorphPartOfSpeech","getMorphTierValue","morphTier","Title","title","id","Video","src","this","props","controls","controlsList","css","removeAttr","attr","audio","document","getElementById","video","paused","pause","play","currentTime","bodyheight","height","React","Component","SpeakerInfo","speaker_list","speaker_id","speaker_display","generate","Metadata","description","author","MoreMetadata","glosser","source","Info","className","MoreInfo","TierCheckbox","state","checkboxState","toggle","bind","event","setState","tier_id","tier_name","onClick","defaultChecked","TierCheckboxList","output","VideoButton","hide","show","Settings","videoButton","hasVideo","Minibar","Sidebar","Row","numSlots","finalSlot","currentSlot","v","text","diff","colSpan","size","data-tier","Sentence","rowList","UntimedTextDisplay","Apagar","startTime","window","activeElement","getAttribute","filho","parentElement","removeChild","ApagarElement","then","data","json","cont","forEach","trilha","ApagarTrilhanoJSON","LabeledSentence","label","isTimeAligned","TimeBlock","LabeledTimeBlock","timestamp","r","Number","e","o","printSeconds","minStart","POSITIVE_INFINITY","maxEnd","NEGATIVE_INFINITY","endTime","data-start_time","data-end_time","href","capture-start-time","TimedTextDisplay","timesToSentences","uniqueTimestamps","timestampMs","timestampSec","b","correspondingSentences","CenterPanel","timed","setupTextSync","scrollIntoViewIfNeeded","target","rect","getBoundingClientRect","bottom","innerHeight","scrollIntoView","top","sync","current_time","ts_tag_array","parseFloat","ts_start_time_array","ts_stop_time_array","setAttribute","style","backgroundColor","removeAttribute","err","media","querySelectorAll","getElementsByClassName","click","jumpToTime","Story","story","footer","audioFile","data-live","initialState","participant","starttime","endtime","Insert","translations","transcriptions","captureInfo","verifyCompatibleWithLenghtOfMedia","setSentenceOnJSON","handleChangeParticipant","handleChangeTranslations","handleChangeTranscriptions","handleChangeStartTime","handleChangeEndTime","S1","of","duration","setJSONCallback","value","htmlFor","onChange","NotFound","parseXml","parseString","elan","Stories","fileInput","createRef","open_file","setJSON","fileLoadend","xml","ref","reader1","FileReader","reader2","readAsText","current","files","onload","result","readAsDataURL","nameFile","res","err2","ANNOTATION_DOCUMENT","component","Export","NewProject","createJSON","fileMedia","loadFiles","reader","onInput","Home","App","exact","render","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM"],"mappings":"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","file":"static/js/main.1cfe33d6.chunk.js","sourcesContent":["const fs = require('fs-web');\n// const parseXml = require('xml2js').parseString;\n// const eafUtils = require('./eaf_utils');\nconst {getAlignableAnnotationStartSlot, \n  getAlignableAnnotationEndSlot, getDocID, \n  getNonemptyTiers, getParentTierName, \n  getTierName, isTierSubdivided,\n  getAnnotationValue, getAnnotations,\n  getAnnotationID, getAnnotationIDMap, \n  getDocTimeslotsMap, getTierSpeakerName, \n  getTierChildrenMap, getTierLanguage} = require('./eaf_utils')\n// const pfsxUtils = require('./pfsx_utils');\nconst pfsxUtils = require ('./pfsx_utils')\nconst helper = require('./helper_functions');\n\n// function updateIndex(indexMetadata, indexFileName, storyID) {\n//   let index = JSON.parse(fs.readFileSync(indexFileName, \"utf8\"));\n//   index[storyID] = indexMetadata;\n//   fs.writeFileSync(indexFileName, JSON.stringify(index, null, 2));\n// }\n\n// Stretch children to fill full duration of parent.\n// Specifically, if parent has P slots and child has C slots (incl gaps except final gap),\n// then increase the child's slots by a factor of P/C,\n// i.e., subtract parentStartSlot from everything, \n//   set each c in C to floor(c * (double) P / (double) C),\n//   and then add parentStartSlot back in. \nfunction scaledSlot(slotIn, parentStart, tierEnd, latestEnd) {\n  const parentLen = latestEnd - parentStart;\n  const childLen = tierEnd - parentStart;\n  let slot = slotIn - parentStart;\n  slot = Math.floor(slot * parentLen / childLen);\n  slot = slot + parentStart;\n  return slot;\n}\n\nfunction assignSlots(anotID, tiersToConstraints,\n    annotationChildren, annotationsFromIDs, timeslots, startSlots, endSlots) {\n  assignSlotsHelper(anotID, 0, tiersToConstraints,\n    annotationChildren, annotationsFromIDs, timeslots, startSlots, endSlots);\n  // At this point, startSlots and endSlots contain the smallest allowable slot value.\n  stretchSlots(anotID, 0, tiersToConstraints,\n    annotationChildren, annotationsFromIDs, timeslots, startSlots, endSlots);\n}\n\nfunction assignSlotsHelper(anotID, parentStartSlot, tiersToConstraints,\n    annotationChildren, annotationsFromIDs, timeslots, startSlots, endSlots) {\n  startSlots[anotID] = parentStartSlot;\n  let latestEndSlot = parentStartSlot + 1;\n  for (const depTierName in annotationChildren[anotID]) {\n    if (annotationChildren[anotID].hasOwnProperty(depTierName)) {\n      let slotNum = parentStartSlot;\n      \n      let prevTimeslot = null; // used for detecting gaps\n      let maybeGaps = (tiersToConstraints[depTierName] === 'Included_In');\n      if (maybeGaps) {\n        prevTimeslot = getAlignableAnnotationStartSlot(annotationsFromIDs[anotID]);\n      }\n      \n      const depAnotIDs = annotationChildren[anotID][depTierName];\n      for (var depAnotID of depAnotIDs) {\n        if (maybeGaps) {\n          const startTimeslot = getAlignableAnnotationStartSlot(annotationsFromIDs[depAnotID]);\n          if (startTimeslot !== prevTimeslot \n            && timeslots[startTimeslot] !== timeslots[prevTimeslot]) {\n            slotNum++;  \n          }\n          prevTimeslot = getAlignableAnnotationEndSlot(annotationsFromIDs[depAnotID]);\n        }\n        \n        assignSlotsHelper(depAnotID, slotNum, tiersToConstraints, annotationChildren, \n            annotationsFromIDs, timeslots, startSlots, endSlots);\n        slotNum = endSlots[depAnotID];\n        latestEndSlot = Math.max(latestEndSlot, slotNum);\n      }\n    }\n  }\n  \n  // make parent's end slot at least as late as its child's\n  endSlots[anotID] = latestEndSlot;\n}\n\n// Stretch children to fill full duration of parent.\n// prevStretch: the total increase in the parent's startslot due to stretch\nfunction stretchSlots(anotID, prevStretch, tiersToConstraints,\n    annotationChildren, annotationsFromIDs, timeslots, startSlots, endSlots) {\n  for (const depTierName in annotationChildren[anotID]) {\n    if (annotationChildren[anotID].hasOwnProperty(depTierName)) {\n      const depAnotIDs = annotationChildren[anotID][depTierName];\n      const tierEnd = endSlots[depAnotIDs[depAnotIDs.length - 1]] + prevStretch;\n      const parentStart = startSlots[anotID];\n      const parentEnd = endSlots[anotID];\n      for (var depAnotID of depAnotIDs) {\n        const origStart = startSlots[depAnotID];\n        const newStart = scaledSlot(origStart + prevStretch, parentStart, tierEnd, parentEnd);\n        startSlots[depAnotID] = newStart;\n        const scaledEnd = scaledSlot(endSlots[depAnotID] + prevStretch, parentStart, tierEnd, parentEnd);\n        endSlots[depAnotID] = scaledEnd;\n        stretchSlots(depAnotID, newStart - origStart, tiersToConstraints, \n            annotationChildren, annotationsFromIDs, timeslots, startSlots, endSlots);\n      }\n    }\n  }\n}\n\nfunction preprocess(adocIn, pfsxIn, xmlFileName, callback) {\n  const storyID = getDocID(adocIn);\n  const indexMetadata = helper.improveElanIndexData(xmlFileName, storyID, adocIn);\n  //updateIndex(indexMetadata, \"data/index.json\", storyID);\n  //updateIndex(indexMetadata, \"data/index.json\", storyID);\n  const jsonOut = {\n    \"metadata\": indexMetadata,\n    \"sentences\": []\n  };\n  jsonOut.metadata[\"tier IDs\"] = {};\n  jsonOut.metadata[\"speaker IDs\"] = {};\n  jsonOut.metadata[\"story ID\"] = storyID; // TODO is this needed?\n\n  const tiers = getNonemptyTiers(adocIn);\n  const indepTiers = tiers.filter((tier) => getParentTierName(tier) == null);\n  \n  // give each tier an ID\n  let tierIDsFromNames = {};\n  for (let i = 0; i < tiers.length; i++) {\n    const newID = \"T\" + (i + 1).toString();\n    const tier = tiers[i];\n    const tierName = getTierName(tier);\n    jsonOut.metadata[\"tier IDs\"][newID] = {\n      name: tierName,\n      subdivided: isTierSubdivided(tierName, tiers),\n    };\n    tierIDsFromNames[tierName] = newID;\n  }\n  \n  // TODO glom morphs if coming from FLEx?\n  \n  // tiersToConstraints: tierName -> constraintName\n  // (to generate, first create typesToConstraints: linguisticTypeName -> constraintName)\n  const typesToConstraints = {};\n  const linguisticTypes = adocIn.LINGUISTIC_TYPE\n  for (const lingType of linguisticTypes) {\n    const lingTypeID = lingType.$.LINGUISTIC_TYPE_ID;\n    const constraintName = lingType.$.CONSTRAINTS || '';\n    typesToConstraints[lingTypeID] = constraintName;\n  }\n  const tiersToConstraints = {};\n  for (const tier of tiers) {\n    const tierName = getTierName(tier);\n    const linguisticType = tier.$.LINGUISTIC_TYPE_REF;\n    const constraintName = typesToConstraints[linguisticType];\n    tiersToConstraints[tierName] = constraintName;\n  }\n  // console.log(`tiersToConstraints: ${tiersToConstraints}`);\n  \n  const untimedTiers = tiers.filter(tier => \n    (tiersToConstraints[getTierName(tier)] === 'Symbolic_Subdivision' \n    || tiersToConstraints[getTierName(tier)] === 'Symbolic_Association')\n  );\n  \n  // annotationChildren: parentAnnotationID -> childTierName(very sparse) -> listof childAnnotationID\n  const annotationChildren = {};\n  for (const tier of untimedTiers) {\n    const childTierName = getTierName(tier);\n    // console.log(`adding untimed child tier ${childTierName} to annotationChildren`);\n    for (const annotation of getAnnotations(tier)) {\n      const childAnnotationID = getAnnotationID(annotation);\n      let parentAnnotationID = annotation.REF_ANNOTATION[0].$.ANNOTATION_REF; \n      \n      if (annotationChildren[parentAnnotationID] == null) {\n        annotationChildren[parentAnnotationID] = {}\n      }\n      if (annotationChildren[parentAnnotationID][childTierName] == null) {\n        annotationChildren[parentAnnotationID][childTierName] = [];\n      }\n      annotationChildren[parentAnnotationID][childTierName].push(childAnnotationID);\n    }\n  }\n  \n  const annotationsFromIDs = getAnnotationIDMap(tiers);\n  const timeslots = getDocTimeslotsMap(adocIn);\n  \n  // sort untimed children\n  for (const parentAnnotationID in annotationChildren) {\n    if (annotationChildren.hasOwnProperty(parentAnnotationID)) {\n      for (const childTierName in annotationChildren[parentAnnotationID]) {\n        const childIDs = annotationChildren[parentAnnotationID][childTierName];\n        let sortedChildIDs = [];\n        const constraint = tiersToConstraints[childTierName];\n        if (constraint === 'Symbolic_Association') { // 1-1 association\n          // assert childIDs.length === 1; \n          sortedChildIDs = childIDs;\n        } else if (constraint === 'Symbolic_Subdivision') { // untimed subdivision, ordered\n          let prev = '';\n          for (const id of childIDs) {\n            const cur = childIDs.find(a => \n              prev === (annotationsFromIDs[a].REF_ANNOTATION[0].$.PREVIOUS_ANNOTATION || '')\n            );\n            sortedChildIDs.push(cur);\n            prev = cur;\n          }\n        } else { // this should never happen\n          console.log(`WARNING: missing or unrecognized ELAN stereotype for tier ${childTierName}. Annotations may display out of order.`);\n          sortedChildIDs = childIDs;\n        }\n        \n        annotationChildren[parentAnnotationID][childTierName] = sortedChildIDs;\n      }\n    }\n  }\n  \n  const tierChildren = getTierChildrenMap(tiers);\n  \n  // add sorted 'Time_Subdivision' children\n  for (const parentTier of tiers) {\n    const childTierNames = tierChildren[getTierName(parentTier)] || [];\n    const timeSubdivChildTiers = tiers.filter(tier => \n      tiersToConstraints[getTierName(tier)] === 'Time_Subdivision'\n      && childTierNames.find(n => n === getTierName(tier)) != null\n    );\n    for (const childTier of timeSubdivChildTiers) {\n      const childTierName = getTierName(childTier);\n      // console.log(`adding time-subdiv child tier ${childTierName} to annotationChildren`);\n      const childTierAnots = getAnnotations(childTier);\n      for (const parentAnot of getAnnotations(parentTier)) {\n        const sortedChildIDs = [];\n        let prevSlot = getAlignableAnnotationStartSlot(parentAnot);\n        const endSlot = getAlignableAnnotationEndSlot(parentAnot);\n        while (prevSlot !== endSlot) {\n          /* partial procedural rewrite of find code: \n          let cur;\n          for (const childAnot of childAnots) {\n            const childSlot = getAlignableAnnotationStartSlot(childAnot);\n            if (prevSlot === childSlot) {\n              cur = childAnot;\n              \n            }\n          }*/\n          const cur = childTierAnots.find(a => \n            prevSlot === getAlignableAnnotationStartSlot(a) || \n            (timeslots[prevSlot] != null && \n            timeslots[prevSlot] === getAlignableAnnotationStartSlot(a)\n            )\n          );\n          if (cur == null) {\n            // this parent anot has no children on this tier\n            break; // exit the while loop\n          }\n          const curID = getAnnotationID(cur);\n          sortedChildIDs.push(curID);\n          prevSlot = getAlignableAnnotationEndSlot(cur);\n        }\n        \n        const parentAnotID = getAnnotationID(parentAnot);\n        if (sortedChildIDs.length !== 0) {\n          if (annotationChildren[parentAnotID] == null) {\n            annotationChildren[parentAnotID] = {}\n          }\n          annotationChildren[parentAnotID][childTierName] = sortedChildIDs;\n        }\n      }\n    }\n  }\n  \n  // add 'Included_In' children\n  for (const parentTier of tiers) {\n    const parentTierName = getTierName(parentTier);\n    const childTierNames = tierChildren[getTierName(parentTier)] || [];\n    const inclChildTiers = tiers.filter(tier => \n      tiersToConstraints[getTierName(tier)] === 'Included_In'\n      && childTierNames.find(n => n === getTierName(tier)) != null\n    );\n    for (const childTier of inclChildTiers) {\n      const childTierName = getTierName(childTier);\n      // console.log(`adding incl-in child tier ${childTierName} of ${parentTierName} to annotationChildren`);\n      const childTierAnots = getAnnotations(childTier);\n      for (const parentAnot of getAnnotations(parentTier)) {\n        let childIDs = [];\n        const parentStartSlot = getAlignableAnnotationStartSlot(parentAnot);\n        const parentEndSlot = getAlignableAnnotationEndSlot(parentAnot);\n        \n        const parentStartMs = timeslots[parentStartSlot];\n        const parentEndMs = timeslots[parentEndSlot];\n        if (parentStartMs && parentEndMs) { // get children within these ms values\n          // console.log(`within ms ${parentStartMs}, ${parentEndMs}?`);\n          for (var anot of childTierAnots) {\n            const anotID = getAnnotationID(anot);\n            const startSlot = getAlignableAnnotationStartSlot(anot);\n            const endSlot = getAlignableAnnotationEndSlot(anot);\n            // console.log(`  checking child ${anotID}, slots ${startSlot}, ${endSlot}`);\n            const startsWithin = (\n              timeslots[startSlot] >= parentStartMs \n              && timeslots[startSlot] < parentEndMs\n            );\n            const endsWithin = (\n              timeslots[endSlot] > parentStartMs \n              && timeslots[endSlot] <= parentEndMs\n            );\n            if (startsWithin || endsWithin) {\n              // console.log('  added!');\n              childIDs.push(anotID);\n            }\n          }\n          \n          // sort by ms value\n          childIDs = childIDs.sort((id1,id2) => {\n            // if start isn't defined, calculate it based on end, pretending duration is 1 ms\n            const a1 = annotationsFromIDs[id1];\n            const a2 = annotationsFromIDs[id2];\n            const start1 = (\n              timeslots[getAlignableAnnotationStartSlot(a1)]\n              || timeslots[getAlignableAnnotationEndSlot(a1)] - 1\n            );\n            const start2 = (\n              timeslots[getAlignableAnnotationStartSlot(a2)] \n              || timeslots[getAlignableAnnotationEndSlot(a2)] - 1\n            );\n            return start1 - start2;\n          });\n        }\n        \n        // check for children which share the parent's start or end slot\n        for (anot of childTierAnots) {\n          const anotID = getAnnotationID(anot);\n          const startSlot = getAlignableAnnotationStartSlot(anot);\n          const endSlot = getAlignableAnnotationEndSlot(anot);\n          if (startSlot === parentStartSlot && anotID !== childIDs[0]) {\n            childIDs.splice(0, 0, anotID); // insert at beginning\n          } else if (endSlot === parentEndSlot && anotID !== childIDs[childIDs.length - 1]) {\n            childIDs.push(anotID);\n          } \n        }\n        \n        // add children which share a boundary with an existing child\n        // (but not if they end at the first child or start at the last child)\n        let prevIndex = 0;\n        while (prevIndex < childIDs.length - 1) {\n          const prevID = childIDs[prevIndex];\n          const prevAnot = annotationsFromIDs[prevID];\n          const prevSlot = getAlignableAnnotationEndSlot(prevAnot);\n          \n          const nextID = childIDs[prevIndex + 1];\n          const nextAnot = annotationsFromIDs[nextID];\n          const nextSlot = getAlignableAnnotationStartSlot(nextAnot)\n          \n          let newAnot = childTierAnots.find(a => \n            getAlignableAnnotationStartSlot(a) === prevSlot\n          );\n          if (newAnot == null) {\n            newAnot = childTierAnots.find(a =>\n              getAlignableAnnotationEndSlot(a) === nextSlot\n            );\n          }\n          if (newAnot != null) {\n            const newID = getAnnotationID(newAnot);\n            if (newID != null && newID != nextID) {\n              childIDs.splice(prevIndex + 1, 0, newID); // insert after prevIndex\n            }\n          }\n          \n          prevIndex++;\n        }\n        \n        const parentAnotID = getAnnotationID(parentAnot);\n        if (!annotationChildren.hasOwnProperty(parentAnotID)) {\n          annotationChildren[parentAnotID] = {};\n        }\n        annotationChildren[parentAnotID][childTierName] = childIDs;\n      }\n    }\n  }\n  \n  //jsonOut['annotationChildren'] = annotationChildren; // TODO remove when no longer needed for debugging\n  \n  const anotDescendants = {}; // indepAnotID -> depTierName -> ordered listof anotIDs descended from indepAnot\n  for (const indepTier of indepTiers) {\n    for (const indepAnot of getAnnotations(indepTier)) {\n      const indepAnotID = getAnnotationID(indepAnot);\n      const depTiersAnots = {}; // depTierName -> ordered listof anotIDs descended from indepAnot\n      let pendingParentIDs = [indepAnotID];\n      while (pendingParentIDs.length > 0) {\n        const parentID = pendingParentIDs[0];\n        pendingParentIDs.shift() // remove parentID from pendingParentIDs\n        // add all of parentID's direct children to depTierAnots and to pendingParentIDs\n        for (const depTierName in annotationChildren[parentID]) {\n          if (annotationChildren[parentID].hasOwnProperty(depTierName)) {\n            const childIDs = annotationChildren[parentID][depTierName];\n            if (!depTiersAnots.hasOwnProperty(depTierName)) {\n              depTiersAnots[depTierName] = [];\n            }\n            depTiersAnots[depTierName] = depTiersAnots[depTierName].concat(childIDs);\n            pendingParentIDs = pendingParentIDs.concat(childIDs);\n          }\n        }\n      }\n      anotDescendants[indepAnotID] = depTiersAnots;\n    }\n  }\n  //jsonOut['anotDescendants'] = anotDescendants; // TODO remove when no longer needed for debugging\n  \n  const garbageTierNames = pfsxUtils.getHiddenTiers(pfsxIn);\n  let garbageTierIDs = [];\n  for (const garbageTierName of garbageTierNames) {\n    garbageTierIDs.push(tierIDsFromNames[garbageTierName]);\n  }\n  \n  const tierNameOrder = pfsxUtils.getTierOrder(pfsxIn);\n  let tierIDOrder = [];\n  for (const tierName of tierNameOrder) {\n    tierIDOrder.push(tierIDsFromNames[tierName]);\n  }\n  \n  // careful - garbageTierIDs and tierIDOrder may contain undefined, e.g. if there are empty tiers\n  \n  for (let i = 0; i < indepTiers.length; i++) {\n    const spkrID = \"S\" + (i + 1).toString(); // assume each independent tier has a distinct speaker\n    const indepTierName = getTierName(indepTiers[i]);\n    const tierID = tierIDsFromNames[indepTierName];\n    \n    jsonOut.metadata[\"speaker IDs\"][spkrID] = {\n      \"name\": getTierSpeakerName(indepTiers[i]),\n      \"language\": getTierLanguage(indepTiers[i]),\n      \"tier\": tierID,\n    };\n    \n    for (const indepAnot of getAnnotations(indepTiers[i])) {\n      const indepAnotID = getAnnotationID(indepAnot);\n      const anotStartSlots = {};\n      const anotEndSlots = {};\n      assignSlots(indepAnotID, tiersToConstraints, annotationChildren, \n        annotationsFromIDs, timeslots, anotStartSlots, anotEndSlots\n      );\n      \n      const sentenceJson = {\n        \"speaker\": spkrID,\n        \"tier\": tierID,\n        \"start_time_ms\": parseInt(timeslots[getAlignableAnnotationStartSlot(indepAnot)], 10),\n        \"end_time_ms\": parseInt(timeslots[getAlignableAnnotationEndSlot(indepAnot)], 10),\n        \"num_slots\": anotEndSlots[indepAnotID],\n        \"text\": getAnnotationValue(indepAnot),\n        //\"anotID\": indepAnotID, // TODO remove when no longer needed for debugging\n        \"dependents\": [],\n      };\n      \n      const depTiersAnots = anotDescendants[indepAnotID];\n      for (const depTierName in depTiersAnots) {\n        if (depTiersAnots.hasOwnProperty(depTierName)) {\n          const depTierJson = {\n            \"tier\": tierIDsFromNames[depTierName],\n            \"values\": [],\n          };\n          \n          for (const depAnotID of depTiersAnots[depTierName]) {\n            const depAnot = annotationsFromIDs[depAnotID];\n            if (!anotStartSlots.hasOwnProperty(depAnotID)) {\n              console.log(`oh no, missing annotation!`);\n            }\n            depTierJson.values.push({\n              \"start_slot\": anotStartSlots[depAnotID],\n              \"end_slot\": anotEndSlots[depAnotID],\n              //\"anotID\": getAnnotationID(depAnot), // TODO remove when no longer needed for debugging\n              \"value\": getAnnotationValue(depAnot),\n            });\n          }\n          // depTierJson is already in order by start_slot, since anotDescendants is ordered\n          sentenceJson.dependents.push(depTierJson); \n        }\n      }\n      \n      if (tierIDOrder.length !== 0) {\n        const orderedDependents = [];\n        for (const tierID of tierIDOrder) {\n          const tier = sentenceJson.dependents.find((t) => t.tier === tierID);\n          if (tier != null) {\n            orderedDependents.push(tier);\n          }\n        }\n        sentenceJson[\"dependents\"] = orderedDependents;\n      }\n      \n      // remove hidden dependent tiers\n      sentenceJson.dependents = sentenceJson.dependents.filter((t) => !garbageTierIDs.includes(t.tier));\n      // remove the independent tier if it's hidden\n      if (garbageTierIDs.includes(sentenceJson[\"tier\"])) {\n        sentenceJson[\"text\"] = \"\";\n        sentenceJson[\"noTopRow\"] = \"true\";\n      }\n      \n      // sort by the numerical part of the tier ID to ensure consistent ordering; TODO delete this line\n      // sentenceJson.dependents.sort((t1,t2) => parseInt(t1.tier.slice(1),10) - parseInt(t2.tier.slice(1),10));\n          \n      jsonOut.sentences.push(sentenceJson);\n    }\n  }\n  jsonOut.sentences.sort((s1,s2) => s1.start_time_ms - s2.start_time_ms);\n  \n  for (const tier in jsonOut.metadata[\"tier IDs\"]) {\n    if (jsonOut.metadata[\"tier IDs\"].hasOwnProperty(tier) && garbageTierIDs.includes(tier)) {\n      delete jsonOut.metadata[\"tier IDs\"][tier];\n    }\n  }\n  \n  //const jsonPath = jsonFilesDir + storyID + \".json\";\n  //fs.writeFileSync(jsonPath, JSON.stringify(jsonOut, null, 2));\n  fs.writeFile(\"data/eaf_temp.json\", JSON.stringify(jsonOut, null, 2));\n  // fs.readString(\"data/eaf_temp.json\").then((data) => {\n  //   console.log(data)\n  // })\n  // console.log(\"  Correctly wrote \" + storyID + \".json\");\n  //callback();\n}\n\n// function preprocess_dir(eafFilesDir, jsonFilesDir, callback) {\n//   const eafFileNames = fs.readdirSync(eafFilesDir).filter(f => \n//     f[0] !== \".\" && f.slice(-4) !== 'pfsx'\n//   ); // excludes pfsx files (which are generated just by opening ELAN) and hidden files\n  \n//   // use this to wait for all preprocess calls to terminate before executing the callback\n//   const status = {numJobs: eafFileNames.length};\n//   if (eafFileNames.length === 0) {\n//     callback();\n//   }\n\n//   const whenDone = function () {\n//     status.numJobs--;\n//     if (status.numJobs <= 0) {\n//       callback();\n//     }\n//   };\n\n//   for (const eafFileName of eafFileNames) {\n//     console.log(\"Processing \" + eafFileName);\n//     const eafPath = eafFilesDir + eafFileName;\n    \n//     // parse .pfsx file, if found\n//     let pfsxJson = null;\n//     let pfsxPath = eafPath.slice(0, -4) + \".pfsx\";\n//     fs.readFile(pfsxPath, function(err1, xmlData) {\n//       if (err1) {\n//         console.log(`WARN: Could not find .pfsx file for ${eafFileName}. Viewing preferences won't be used.`);\n//       } else {\n//         parseXml(xmlData, function (err2, jsonData) {\n//           if (err2) throw err2; \n//           pfsxJson = jsonData;\n//         });\n//       }\n//     });\n    \n//     fs.readFile(eafPath, function (err1, xmlData) {\n//       if (err1) throw err1;\n//       parseXml(xmlData, function (err2, jsonData) {\n//         if (err2) throw err2;\n//         const adoc = jsonData.ANNOTATION_DOCUMENT;\n//         preprocess(adoc, pfsxJson, jsonFilesDir, eafFileName, whenDone);\n//       });\n//     });\n//   }\n// }\n\nmodule.exports = {\n  //preprocess_dir: preprocess_dir,\n  preprocess: preprocess,\n  assignSlots: assignSlots, // TODO remove when no longer needed for debugging\n};\n","/* functions for accessing data within ELAN's format (except parsed to JSON): */\n\n// adoc - an annotation document\n// returns the hexadecimal code from the URN, or null if none was found\nfunction getDocID(adoc) {\n  const properties = adoc.HEADER[0].PROPERTY;\n  for (const property of properties) {\n    if (property.$.NAME === 'URN') {\n      const urn = property._;\n      return urn.substring(urn.lastIndexOf(':') + 1);\n    }\n  }\n  return null;\n}\n\n// adoc - an annotation document\n// returns a map from each timeslotID to its time value in ms\nfunction getDocTimeslotsMap(adoc) {\n  const timeslotsIn = adoc.TIME_ORDER[0].TIME_SLOT;\n  if (timeslotsIn == null) { // this happens on newly created ELAN files\n    console.log(\"WARN: No timing information found. It looks like this ELAN file doesn't have any annotations.\");\n    return {};\n  }\n  let timeslots = [];\n  for (const slot of timeslotsIn) {\n    timeslots[slot.$.TIME_SLOT_ID] = parseInt(slot.$.TIME_VALUE, 10);\n  }\n  return timeslots;\n}\n\n// adoc - an annotation document\n// returns a list of tiers (JSON objects)\nfunction getNonemptyTiers(adoc) {\n  const allTiers = adoc.TIER;\n  return allTiers.filter((tier) =>\n      tier.ANNOTATION != null && tier.ANNOTATION.length > 0\n  );\n}\n\n// returns a map: tier name -> list of tier names of its children\nfunction getTierChildrenMap(tiers) {\n  const tierChildren = {};\n  for (const tier of tiers) {\n    const parentName = getParentTierName(tier);\n    if (parentName != null) {\n      if (tierChildren[parentName] == null) {\n        tierChildren[parentName] = [];\n      }\n      tierChildren[parentName].push(getTierName(tier));\n    }\n  }\n  return tierChildren;\n}\n\n// `children` should be a lookup table from each element to its list of children\nfunction getDescendants(ancestor, children) { // not including ancestor itself\n  if (children[ancestor] == null) {\n    return [];\n  }\n  let descendants = children[ancestor];\n  for (const child of children[ancestor]) {\n    descendants = descendants.concat(getDescendants(child, children));\n  }\n  return descendants;\n}\n\n// return a map from indep tier name to list of dep tier names\nfunction getTierDependentsMap(tiers) {\n  const indepTiers = tiers.filter((tier) => getParentTierName(tier) == null);\n  const tierChildren = getTierChildrenMap(tiers);\n  let tierDependents = {};\n  for (const indepTier of indepTiers) {\n    const indepTierName = getTierName(indepTier);\n    tierDependents[indepTierName] = getDescendants(indepTierName, tierChildren);\n  }\n  return tierDependents;\n}\n\nfunction getAnnotationIDMap(tiers) {\n  const annotationsFromIDs = {};\n  for (const tier of tiers) {\n    for (const annotation of getAnnotations(tier)) {\n      const annotationID = getInnerAnnotationID(unwrapAnnotation(annotation));\n      annotationsFromIDs[annotationID] = annotation;\n    }\n  }\n  return annotationsFromIDs;\n}\n\n// comparison function for timeslot IDs\nfunction slotIDDiff(slot1, slot2) {\n  return parseInt(slot1.slice(2)) - parseInt(slot2.slice(2));\n}\n\n/* return a map: independent_tier_id -> timeslot_id -> rank,\n  where a timeslot's \"rank\" is what its index would be\n  in a time-ordered array of the unique timeslots for this speaker */\nfunction getTierTimeslotsMap(tiers) {\n  const indepTiers = tiers.filter((tier) => getParentTierName(tier) == null);\n  const tierDependents = getTierDependentsMap(tiers);\n  const tierTimeslots = {};\n  for (const indepTier of indepTiers) {\n    const indepTierName = getTierName(indepTier);\n\n    let slotsSet = getTimeslotSet(indepTier); // use a set to omit duplicates\n    for (const maybeDepTier of tiers) {\n      if (tierDependents[indepTierName].includes(getTierName(maybeDepTier))) {\n        // maybeDepTier is a dependent of indepTier\n        for (const slot of getTimeslotSet(maybeDepTier)) {\n          slotsSet.add(slot);\n        }\n      }\n    }\n    const slotsArray = Array.from(slotsSet);\n\n    // sort by the numerical part of the timeslot ID\n    const sortedSlots = slotsArray.sort(slotIDDiff);\n\n    // create a map from timeslot ID to its \"rank\" (its position in the sorted array)\n    let slotRanks = {};\n    for (const slotIndex in sortedSlots) {\n      if (sortedSlots.hasOwnProperty(slotIndex)) {\n        slotRanks[sortedSlots[slotIndex]] = slotIndex;\n      }\n    }\n    tierTimeslots[indepTierName] = slotRanks;\n  }\n  return tierTimeslots;\n}\n\n// return true if tier has alignable annotations, false if it has ref annotations\nfunction isTierAlignable(tier) {\n  return getAnnotations(tier)[0].ALIGNABLE_ANNOTATION != null;\n}\n\nfunction isTierSubdivided(tierName, tiers) { // true iff tierName has a dependent, aligned ancestor tier\n  return getParentTierName(getTierAlignedAncestor(tierName, tiers)) != null;\n}\n\nfunction getTierAlignedAncestor(tierName, tiers) {\n  let currentTier = tiers.find(tier => getTierName(tier) === tierName);\n  while (!isTierAlignable(currentTier)) {\n    currentTier = tiers.find(tier => getTierName(tier) === getParentTierName(currentTier));\n  }\n  return currentTier;\n}\n\n// returns the ELAN-user-specified tier name (string)\nfunction getTierName(tier) {\n  return tier.$.TIER_ID;\n}\n\n// returns the ELAN-user-specified name of its parent-tier (string), or null if tier is independent\nfunction getParentTierName(tier) {\n  return tier.$.PARENT_REF;\n}\n\n// returns the ELAN-user-specified speaker's name (string or null)\nfunction getTierSpeakerName(tier) {\n  return tier.$.PARTICIPANT;\n}\n\n// returns the tier's language (a string), which is often an ISO code\nfunction getTierLanguage(tier) {\n  return tier.$.LANG_REF;\n}\n\nfunction getAnnotations(tier) {\n  return tier.ANNOTATION;\n}\n\n// return the set of timeslotIDs referenced in this tier\nfunction getTimeslotSet(tier) {\n  if (!isTierAlignable(tier)) {\n    // no timestamps in this tier; it's all REF_ANNOTATIONs\n    return new Set();\n  }\n  const annotations = getAnnotations(tier);\n  const startSlots = new Set(annotations.map((a) => getAlignableAnnotationStartSlot(a)));\n  const endSlots = new Set(annotations.map((a) => getAlignableAnnotationEndSlot(a)));\n  let allSlots = startSlots;\n  for (const slot of endSlots) {\n    allSlots.add(slot);\n  }\n  return allSlots;\n}\n\nfunction isAnnotationAlignable(annotation) {\n  return annotation.ALIGNABLE_ANNOTATION != null;\n}\n\nfunction unwrapAnnotation(annotation) {\n  if (isAnnotationAlignable(annotation)) {\n    return annotation.ALIGNABLE_ANNOTATION[0];\n  } else {\n    return annotation.REF_ANNOTATION[0];\n  }\n}\n\nfunction getAnnotationID(annotation) {\n  return getInnerAnnotationID(unwrapAnnotation(annotation));\n}\n\nfunction getAnnotationValue(annotation) {\n  return getInnerAnnotationValue(unwrapAnnotation(annotation));\n}\n\n// returns an annotation with the same start and end timeslots as this annotation\nfunction getAnnotationTimedAncestor(annotation, annotationsFromIDs) {\n  let currentannotation = annotation;\n  while (currentannotation.ALIGNABLE_ANNOTATION == null) {\n    const parentAnnotationID = currentannotation.REF_ANNOTATION[0].$.ANNOTATION_REF;\n    currentannotation = annotationsFromIDs[parentAnnotationID];\n  }\n  return currentannotation;\n}\n\nfunction getAnnotationStartSlot(annotation, annotationsFromIDs) {\n  return getInnerAnnotationStartSlot(unwrapAnnotation(getAnnotationTimedAncestor(annotation, annotationsFromIDs)));\n}\n\nfunction getAnnotationEndSlot(annotation, annotationsFromIDs) {\n  return getInnerAnnotationEndSlot(unwrapAnnotation(getAnnotationTimedAncestor(annotation, annotationsFromIDs)));\n}\n\nfunction getAlignableAnnotationStartSlot(annotation) {\n  return getInnerAnnotationStartSlot(unwrapAnnotation(annotation));\n}\n\nfunction getAlignableAnnotationEndSlot(annotation) {\n  return getInnerAnnotationEndSlot(unwrapAnnotation(annotation));\n}\n\nfunction getInnerAnnotationID(innerAnnotation) {\n  return innerAnnotation.$.ANNOTATION_ID;\n}\n\nfunction getInnerAnnotationValue(innerAnnotation) {\n  return innerAnnotation.ANNOTATION_VALUE[0];\n}\n\nfunction getInnerAnnotationStartSlot(innerAnnotation) {\n  return innerAnnotation.$.TIME_SLOT_REF1;\n}\n\nfunction getInnerAnnotationEndSlot(innerAnnotation) {\n  return innerAnnotation.$.TIME_SLOT_REF2;\n}\n\nmodule.exports = {\n  getDocID: getDocID,\n  getDocTimeslotsMap: getDocTimeslotsMap,\n  getNonemptyTiers: getNonemptyTiers,\n  getTierChildrenMap: getTierChildrenMap,\n  getTierDependentsMap: getTierDependentsMap,\n  getAnnotationIDMap: getAnnotationIDMap,\n  slotIDDiff: slotIDDiff,\n  // getTierNamesMap: getTierNamesMap,\n  getTierTimeslotsMap: getTierTimeslotsMap,\n\n  // isTierAlignable: isTierAlignable,\n  isTierSubdivided: isTierSubdivided,\n  // getTierAlignedAncestor: getTierAlignedAncestor,\n  getTierName: getTierName,\n  getParentTierName: getParentTierName,\n  getTierSpeakerName: getTierSpeakerName,\n  getTierLanguage: getTierLanguage,\n  getAnnotations: getAnnotations,\n  // getTimeslotSet: getTimeslotSet,\n\n  isAnnotationAlignable: isAnnotationAlignable,\n  // unwrapAnnotation: unwrapAnnotation,\n  getAnnotationID: getAnnotationID,\n  getAnnotationValue: getAnnotationValue,\n  // getAnnotationTimedAncestor: getAnnotationTimedAncestor,\n  getAnnotationStartSlot: getAnnotationStartSlot,\n  getAnnotationEndSlot: getAnnotationEndSlot,\n  getAlignableAnnotationStartSlot: getAlignableAnnotationStartSlot,\n  getAlignableAnnotationEndSlot: getAlignableAnnotationEndSlot,\n\n  // getInnerAnnotationValue: getInnerAnnotationValue,\n  // getInnerAnnotationStartSlot: getInnerAnnotationStartSlot,\n  // getInnerAnnotationEndSlot: getInnerAnnotationEndSlot,\n};","/* functions for accessing data within ELAN's .pfsx format (except parsed to JSON).\nThe functions return reasonable results even when the parse of the .pfsx file is null,\nto allow for use even if the pfsx file is missing from data/elan_files\nor even if the pfsx file failed to parse. */\n\nfunction getPrefList(listName, jsonData) {\n  if (jsonData == null || jsonData['preferences'] == null || jsonData['preferences']['prefList'] == null) {\n    // jsonData==null or jsonData['preferences']==null means there wasn't a valid pfsx file.\n    // jsonData['preferences']['prefList']==null means there are e.g. tier color preferences, \n    //     but all the list-type preferences are still set to the defaults.\n    \n    return [];\n  }\n  let prefLists = jsonData['preferences']['prefList'];\n  for (let prefList of prefLists) {\n    if (prefList['$'] == null) {\n      // this shouldn't happen, but just skip this prefList and move to the next one \n      continue;\n    }\n    if (prefList['$']['key'] == listName) {\n      \n      return prefList['String'] || []; // assume all prefLists are lists of strings\n    }\n  }\n  \n  return [];\n}\n\nfunction getTierOrder(jsonData) {\n  return getPrefList('MultiTierViewer.TierOrder', jsonData);\n}\n\nfunction getHiddenTiers(jsonData) {\n  return getPrefList('MultiTierViewer.HiddenTiers', jsonData) || [];\n}\n\nmodule.exports = {\n  getTierOrder : getTierOrder,\n  getHiddenTiers : getHiddenTiers,\n}","const fs = require('fs');\nconst flexUtils = require('./flex_utils'); // TODO use me more, and use eafUtils too, for stylistic consistency\n\nfunction getMetadataFromIndex(filename) {\n  // I/P: filename, an XML or EAF file\n  // O/P: a JSON object with metadata for the given file;\n  //      or null if filename not in index\n  // Status: tested, working\n  const index = JSON.parse(fs.readFileSync(\"data/index.json\", \"utf8\"));\n  if (index.hasOwnProperty(filename)) {\n    return index[filename];\n  } else {\n    return null;\n  }\n}\n\nfunction getFilenameFromPath(path) {\n  // I/P: path, a string\n  // O/P: the filename which occurs at the end of the path\n  // Status: untested\n  const begin = String(path).lastIndexOf(\"/\") + 1; // @Kalinda, this might fail on windows.\n  return String(path).substring(begin, path.length);\n}\n\nfunction getFlexMediaFilenames(itext) {\n  let filenames = [];\n  const mediaFiles = itext[\"media-files\"];\n  if (mediaFiles != null) {\n    const mediaList = mediaFiles[0].media;\n    for (const media of mediaList) {\n      filenames.push(media.$.location);\n    }\n  }\n  return filenames;\n}\n\nfunction verifyMedia(filename) {\n  // I/P: filename, a .mp3 or .mp4 file\n  // O/P: boolean, whether or not file exists in media_files directory\n  // Status: untested\n  // const media_files = fs.readdirSync(\"data/media_files\");\n  // return (media_files.indexOf(filename) >= 0);\n  return \"\"\n}\n\nfunction findValidMedia(filenames) {\n  // I/P: filenames, a list of filenames (file extension included) that would be considered a match\n  // O/P: the first filename in the list that we can use as media, or null if none was found\n  for (const mediaFilename of filenames) {\n    if (verifyMedia(mediaFilename)) {\n      return mediaFilename;\n    }\n  }\n  return null;\n}\n\nfunction mediaSearch(filename, mediaType, mediaFiles, extension) {\n  // I/P: filename, the name of the ELAN or FLEx file\n  // I/P: mediaType, which is either \"video\" or \"audio\", for printing to the command line\n  // I/P: mediaFiles, a list of the media files that were linked in the ELAN or FLEx file\n  // I/P: extension, file extension for media files, including the leading period\n  // O/P: the filename of the first valid media that was found, or null if none exists\n  console.log(\"  WARN: \" + filename + \" is missing correctly linked \" + mediaType + \". Attemping to find link...\");\n  const shortFilename = String(filename).substring(0, String(filename).lastIndexOf('.'));\n  const shortestFilename = String(filename).substring(0, filename.indexOf('.')); // more possible matches for .postflex.flextext files\n  const filenamesToTry = mediaFiles.concat([shortFilename + extension, shortestFilename + extension]);\n  const mediaFile = findValidMedia(filenamesToTry);\n  if (mediaFile != null) {\n    console.log(\"  SUCCESS: Found matching \" + mediaType + \": \" + mediaFile);\n  } else {\n    console.log(\"  ERROR: Cannot find matching \" + mediaType + \" for \" + shortFilename + \". \");\n  }\n  return mediaFile;\n}\n\nfunction updateMediaMetadata(filename, storyID, metadata, linkedMediaPaths) {\n  // Only call this function if the file contains timestamps.\n  // I/P: filename, of the FLEx or ELAN file\n  // I/P: storyId, the unique ID of this document\n  // I/P: metadata, a json object formatted for use on the site\n  // I/P: linkedMediaPaths, a list of media file paths mentioned in the FLEx or ELAN file \n  // O/P: updates metadata by filling in any missing audio/video file names, if we can,\n  //  and setting timed=false if we can't find any audio/video files\n  \n  metadata['timed'] = true;\n\n  const audioFile = metadata['media']['audio'];\n  let hasWorkingAudio = verifyMedia(audioFile);\n  if (!hasWorkingAudio) {\n    metadata['media']['audio'] = \"\";\n  }\n  const videoFile = metadata['media']['video'];\n  let hasWorkingVideo = verifyMedia(videoFile);\n  if (!hasWorkingVideo) {\n    metadata['media']['video'] = \"\";\n  }\n\n  // If both audio/video work, then we're done. Otherwise, figure out what we need.\n  if (hasWorkingAudio && hasWorkingVideo) {\n    return;\n  }\n  let needsAudio = false;\n  let needsVideo = false;\n  let audioFiles = [];\n  let videoFiles = [];\n  for (const mediaPath of linkedMediaPaths) {\n    const mediaFilename = getFilenameFromPath(mediaPath);\n    const fileExtension = String(mediaFilename).substring(String(mediaFilename).lastIndexOf('.')).toLowerCase();\n    if (fileExtension === '.mp3' || fileExtension === '.wav') {\n      audioFiles.push(mediaFilename);\n      needsAudio = true;\n    } else if (fileExtension === '.mp4') {\n      videoFiles.push(mediaFilename);\n      needsVideo = true;\n    }\n  }\n  \n  // Media search\n  if (needsAudio && !hasWorkingAudio) {\n    const audioFile = mediaSearch(filename, \"audio\", audioFiles, \".mp3\");\n    if (audioFile != null) {\n      hasWorkingAudio = true;\n      metadata['media']['audio'] = audioFile;\n    }\n  }\n  if (needsVideo && !hasWorkingVideo) {\n    const videoFile = mediaSearch(filename, \"video\", videoFiles, \".mp4\");\n    if (videoFile != null) {\n      hasWorkingVideo = true;\n      metadata['media']['video'] = videoFile;\n    }\n  }\n  \n  // Worst case scenario: no media\n  if (!hasWorkingAudio && !hasWorkingVideo) {\n    metadata['timed'] = false;\n    console.log(\"  ERROR: \" + filename + \" (unique ID: \" + storyID + \") has no linked audio or video in the media_files directory. It will be processed as an untimed file and no audio, video, or time alignment will be displayed on the site.\");\n  }\n}\n\nfunction getTitleFromFilename(filename) {\n  return String(filename).substring(0, String(filename).lastIndexOf('.'));\n}\n\n// function improveFLExIndexData(path, storyID, itext) {\n//   // I/P: path, a string\n//   //      itext, an interlinear text, e.g., jsonIn[\"document\"][\"interlinear-text\"][0]\n//   // O/P: a JSON object, based on the index.json file and new metadata\n//   // Status: untested\n//   let metadata = getMetadataFromIndex(storyID);\n\n//   const date = new Date();\n//   const prettyDate = (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();\n  \n//   const hasTimestamps = flexUtils.documentHasTimestamps(itext);\n  \n//   // get title/source info, part 1\n//   let titlesAndSources = itext[\"item\"];\n//   let titles = {};\n//   let sources = {};\n//   if (titlesAndSources != null) {\n//     for (const current_title of titlesAndSources) {\n//       if (current_title['$']['type'] === 'title') {\n//         titles[(current_title[\"$\"][\"lang\"])] = current_title[\"_\"];\n//       } else if (current_title['$']['type'] === 'source') {\n//         sources[(current_title[\"$\"][\"lang\"])] = current_title[\"_\"];\n//       }\n//     }\n//   }\n  \n//   if (metadata == null) { // file not in index previously\n  \n//     let defaultTitle = getTitleFromFilename(getFilenameFromPath(path));\n//     // Uncomment the three lines below to use a particular language title \n//     // (in this case \"es\", Spanish) as the main title for newly added documents. \n//     // if (titles[\"es\"] != null && titles[\"es\"] != \"\") {\n//       // defaultTitle = titles[\"es\"];\n//     // }\n  \n//     // below is the starter data:\n//     metadata = {\n//       \"timed\": hasTimestamps,\n//       \"story ID\": storyID,\n//       \"title\": {\n//         \"_default\": defaultTitle,\n//       },\n//       \"media\": {\n//         \"audio\": \"\",\n//         \"video\": \"\"\n//       },\n//       \"languages\": [],\n//       \"date_created\": \"\",\n//       \"date_uploaded\": prettyDate,\n//       \"source\": {\n//         \"_default\": \"\"\n//       },\n//       \"description\": \"\",\n//       \"genre\": \"\",\n//       \"author\": \"\",\n//       \"glosser\": \"\",\n//       \"speakers\": [],\n//       \"xml_file_name\": path,\n//       \"source_filetype\": \"FLEx\"\n//     }\n//   }\n  \n//   // get title/source info, part 2\n//   titles[\"_default\"] = metadata[\"title\"][\"_default\"];\n//   sources[\"_default\"] = metadata[\"source\"][\"_default\"];\n//   metadata[\"title\"] = titles;\n//   metadata[\"source\"] = sources;\n  \n//   // get language info\n//   let languages = [];\n//   let itextLanguages = itext.languages;\n//   if (itextLanguages != null) { // null on .flextext freshly exported from ELAN\n//     const languageData = itextLanguages[0].language;\n//     for (const language of languageData) {\n//       languages.push(language[\"$\"][\"lang\"]);\n//     }\n//   }\n//   metadata[\"languages\"] = languages;\n  \n//   // fill in any missing audio/video files, if we can\n//   const linkedMediaPaths = getFlexMediaFilenames(itext);\n//   const filename = getFilenameFromPath(path);\n//   if (hasTimestamps) {\n//     updateMediaMetadata(filename, storyID, metadata, linkedMediaPaths);\n//   }\n  \n//   return metadata;\n// }\n\nfunction improveElanIndexData(path, storyID, adoc) {\n  // I/P: path, a string\n  //      storyID, a string\n  //      adoc, an annotation document\n  // O/P: a JSON object, based on the index.json file and new metadata\n  // Status: untested\n  const filename = getFilenameFromPath(path);\n  //let metadata = getMetadataFromIndex(storyID);\n  let metadata = null;\n\n  const date = new Date();\n  const prettyDate = (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();\n\n  if (metadata == null) { // file not in index previously\n    // below is the starter data:\n    metadata = {\n      \"timed\": true,\n      \"story ID\": storyID,\n      \"title\": {\n        \"_default\": getTitleFromFilename(filename),\n      },\n      \"media\": {\n        \"audio\": \"\",\n        \"video\": \"\"\n      },\n      \"languages\": [],\n      \"date_created\": \"\",\n      \"date_uploaded\": prettyDate,\n      \"source\": {\n        \"_default\": \"\"\n      },\n      \"description\": \"\",\n      \"genre\": \"\",\n      \"author\": \"\",\n      \"glosser\": \"\",\n      \"speakers\": [],\n      \"xml_file_name\": path,\n      \"source_filetype\": \"ELAN\"\n    };\n  }\n\n  // get language info\n  let speakers = new Set(); // to avoid duplicates\n  const tiers = adoc['TIER'];\n  for (const tier of tiers) {\n    if (tier['$']['PARTICIPANT']) {\n      speakers.add(tier['$']['PARTICIPANT']);\n    }\n  }\n  metadata['speakers'] = Array.from(speakers);\n\n  // fill in any missing audio/video files, if we can\n  let linkedMediaPaths = [];\n  let mediaDescriptors = adoc['HEADER'][0]['MEDIA_DESCRIPTOR'];\n  if (mediaDescriptors != null) { // null happens on ELAN->FLEx->ELAN files\n    for (const mediaDesc of mediaDescriptors) {\n      linkedMediaPaths.push(mediaDesc['$']['MEDIA_URL']);\n    }\n  }\n  //updateMediaMetadata(filename, storyID, metadata, linkedMediaPaths)\n\n  return metadata;\n}\n\nmodule.exports = {\n  //verifyMedia: verifyMedia,\n  getMetadataFromIndex: getMetadataFromIndex,\n  getFilenameFromPath: getFilenameFromPath,\n  //improveFLExIndexData: improveFLExIndexData,\n  improveElanIndexData: improveElanIndexData\n};\n","/* functions for accessing data within FLEx's Verifiable Generic XML and .flextext formats \n(after they've been parsed to JSON): */\n\nfunction getDocumentSourceLang(doc) {\n  const firstSentence = getDocumentFirstSentence(doc);\n  const firstWord = getSentenceWords(firstSentence)[0];\n  if (firstWord != null) {\n    return getWordLang(firstWord);\n  }\n  const textItem = getSentenceTextItemIfExists(firstSentence);\n  // since firstWord was null, assume textItem isn't\n  return textItem.$.lang;\n}\n\nfunction documentHasTimestamps(doc) {\n  return getSentenceStartTime(getDocumentFirstSentence(doc)) != null;\n}\n\nfunction getDocumentFirstSentence(doc) {\n  const firstParagraph = getDocumentParagraphs(doc)[0];\n  return getParagraphSentences(firstParagraph)[0];\n}\n\nfunction getDocumentParagraphs(doc) {\n  let paragraphs = [];\n  const wrappedParagraphs = doc.paragraphs[0].paragraph;\n  for (const wrappedParagraph of wrappedParagraphs) {\n    if (wrappedParagraph.phrases == null) continue; // if this paragraph is empty, skip it instead of erroring\n    let paragraph = wrappedParagraph.phrases[0].word; // for Verifiable Generic XML\n    if (paragraph == null) {\n      paragraph = wrappedParagraph.phrases[0].phrase; // for .flextext\n    }\n    if (paragraph != null) {\n      paragraphs.push(paragraph);\n    }\n  }\n  return paragraphs;\n}\n\nfunction getParagraphSentences(paragraph) {\n  let sentences = [];\n  for (const sentence of paragraph) {\n    sentences.push(sentence); // breakdown within wrappedSentence.words[0].word; free glosses within wrappedSentence.item\n  }\n  return sentences;\n}\n\nfunction getSentenceTextIfNoWords(sentence) {\n  // After starting to gloss a sentence in FLEx, the \"txt\" tier disappears, \n  // replaced by the individual <word>s. In that case, we return null.\n  const textItem = getSentenceTextItemIfExists(sentence);\n  if (textItem != null) {\n    return getFreeGlossValue(textItem);\n  } else {\n    return null;\n  }\n}\n\nfunction getSentenceTextItemIfExists(sentence) {\n  // When exported from ELAN, the sentence's text is formatted like a free gloss, but with type=\"txt\".\n  // Once someone starts glossing the sentence, that item disappears, replaced by individual words,\n  // in which case we return null. \n  for (const gloss of sentence.item) {\n    if (gloss.$.type === \"txt\") {\n      return gloss;\n    }\n  }\n  return null;\n}\n\nfunction getSentenceFreeGlosses(sentence) {\n  let freeGlosses = [];\n  const rawFreeGlosses = sentence.item;\n  for (const gloss of rawFreeGlosses) {\n    if (gloss.$.type === \"gls\") {\n      const glossValue = gloss._;\n      if (glossValue != null) {\n        freeGlosses.push(gloss);\n      } // else there's not actually a gloss here, just the metadata/placeholder for one\n    } // else it might be type \"segnum\" (sentence number) or similar; we'll ignore it\n  }\n  return freeGlosses;\n}\n\nfunction getSentenceStartTime(sentence) {\n  const sentenceProperties = sentence.$;\n  if (sentenceProperties != null) {\n    const timeString = sentenceProperties['begin-time-offset'];\n    if (timeString != null) {\n      return parseInt(timeString, 10);\n    }\n  }\n  return null;\n}\n\nfunction getSentenceEndTime(sentence) {\n  const sentenceProperties = sentence.$;\n  if (sentenceProperties != null) {\n    const timeString = sentenceProperties['end-time-offset'];\n    if (timeString != null) {\n      return parseInt(timeString, 10);\n    }\n  }\n  return null;\n}\n\nfunction getSentenceSpeaker(sentence) {\n  const sentenceProperties = sentence.$;\n  if (sentenceProperties != null) {\n    return sentenceProperties.speaker;\n  }\n  return null;\n}\n\nfunction getSentenceWords(sentence) {\n  if (sentence.words == null) {\n    return [];\n  }\n  let wordList = sentence.words[0].word;\n  if (wordList == null) {\n    // this happens on .flextext files if some sentences, \n    // but not this sentence, have been glossed\n    return [];\n  }\n  return wordList;\n}\n\nfunction getWordMorphs(word) {\n  if (word.morphemes == null) {\n    return [];\n  }\n  return word.morphemes[0].morph;\n}\n\nfunction getWordValue(word) {\n  return word.item[0]._;\n}\n\nfunction getWordLang(word) {\n  return word.item[0].$.lang;\n}\n\nfunction getMorphTiers(morph) {\n  return morph.item;\n}\n\nfunction getMorphPartOfSpeech(morph) {\n  if (morph.$ == null) { // TODO I have no idea why this happens sometimes but it does\n    return null;\n  }\n  return morph.$.type;\n}\n\nfunction getMorphTierValue(morphTier) {\n  return morphTier._;\n}\n\nfunction getFreeGlossValue(freeGloss) {\n  return freeGloss._;\n}\n\nmodule.exports = {\n  getDocumentSourceLang: getDocumentSourceLang,\n  documentHasTimestamps: documentHasTimestamps,\n  getDocumentParagraphs: getDocumentParagraphs,\n  getParagraphSentences: getParagraphSentences,\n  getSentenceTextIfNoWords: getSentenceTextIfNoWords,\n  getSentenceFreeGlosses: getSentenceFreeGlosses,\n  getSentenceStartTime: getSentenceStartTime,\n  getSentenceEndTime: getSentenceEndTime,\n  getSentenceSpeaker: getSentenceSpeaker,\n  getSentenceWords: getSentenceWords,\n  getWordMorphs: getWordMorphs,\n  getWordValue: getWordValue,\n  getMorphTiers: getMorphTiers,\n  getMorphPartOfSpeech: getMorphPartOfSpeech,\n  getMorphTierValue: getMorphTierValue,\n  getFreeGlossValue: getFreeGlossValue,\n};","export function Title({ title }) {\n\t// I/P: title, a string\n\t// O/P: printed title\n\t// Status: tested, working\n\treturn <h3 id=\"title\">{title}</h3>;\n}","import React from 'react'\nimport $ from 'jquery'\nexport class Video extends React.Component {\n\t// I/P: path, the path to the video\n\t// O/P: a video player\n\t// Status: re-written, untested\n\trender() {\n\t\treturn <video src={this.props.path} id=\"video\" controls controlsList=\"nodownload\" />;\n\t}\n\n\tstatic show() {\n\t\t// Resize panels:\n\t\t$('#leftPanel').css('width', '40%');\n\t\t$('#leftPanel').css('height', 'calc(100% - 48px)');\n\t\t$('#centerPanel').css('margin-left', '40%');\n\t\t$('#centerPanel').css('height', 'calc(100% - 48px)');\n\t\t$(\"#centerPanel\").css(\"width\", \"60%\");\n\n\t\t// Deactivate audio:\n\t\t$('#footer').css('display', 'none');\n\t\t$('#audio').removeAttr('ontimeupdate');\n\t\t$('#audio').removeAttr('onclick');\n\t\t$('#audio').attr('data-live', 'false');\n\n\t\t// Activate video:\n\t\t$('#video').css('display', 'inline');\n\t\t$('#video').attr('data-live', 'true');\n\t\t$('#video').attr('ontimeupdate', 'sync(this.currentTime)');\n\t\t$('#video').attr('onclick', 'sync(this.currentTime)');\n\n\t\t// Match times:\n\t\tvar audio = document.getElementById('audio');\n\t\tvar video = document.getElementById('video');\n\t\tif (!audio.paused) {\n\t\t\taudio.pause();\n\t\t\tvideo.play();\n\t\t}\n\t\tvideo.currentTime = audio.currentTime;\n\t}\n\n\tstatic hide() {\n\t\t// Resize panels:\n\t\tvar footheight = ($(\"#footer\").height() + 48).toString() + \"px\";\n\t\tvar bodyheight = \"calc(100% - \" + footheight + \")\";\n\n\t\t$(\"#leftPanel\").css(\"width\", \"300px\");\n\t\t$(\"#leftPanel\").css(\"height\", bodyheight);\n\t\t$(\"#centerPanel\").css(\"height\", bodyheight);\n\t\t$(\"#centerPanel\").css(\"margin-left\", \"300px\");\n\t\t$(\"#centerPanel\").css(\"width\", \"calc(100% - 300px)\");\n\n\t\t// Deactivate video:\n\t\t$(\"#video\").css(\"display\", \"none\");\n\t\t$(\"#video\").removeAttr(\"onclick\");\n\t\t$(\"#video\").removeAttr(\"ontimeupdate\");\n\t\t$(\"#video\").attr(\"data-live\", \"false\");\n\n\t\t// Activate audio:\n\t\t$(\"#footer\").css(\"display\", \"block\");\n\t\t$(\"#audio\").attr(\"data-live\", \"true\");\n\t\t$(\"#audio\").attr(\"ontimeupdate\", \"sync(this.currentTime)\");\n\t\t$(\"#audio\").attr(\"onclick\", \"sync(this.currentTime)\");\n\n\t\t// Match times:\n\t\tvar audio = document.getElementById(\"audio\");\n\t\tvar video = document.getElementById(\"video\");\n\t\tif (!video.paused) {\n\t\t\tvideo.pause();\n\t\t\taudio.play();\n\t\t}\n\t\taudio.currentTime = video.currentTime;\n\t}\n}","import id from 'shortid';\n\nexport function SpeakerInfo({ speakers }) {\n\t// I/P: speakers, a map from speaker IDs to objects containing speaker names, languages, etc.\n\t// O/P: some nicely formatted info about these speakers\n\t// Status: tested, not working\n\tlet speaker_list = [];\n\tif (speakers != null) {\n\t\t// Form a list of speakers:\n\t\tfor (const speaker_id in speakers) {\n\t\t\tif (speakers.hasOwnProperty(speaker_id)) {\n\t\t\t\tconst speaker_name = speakers[speaker_id]['name'];\n\t\t\t\tconst speaker_display = speaker_id + ': ' + speaker_name;\n\t\t\t\tspeaker_list.push(<li key={id.generate()}>{speaker_display}</li>);\n\t\t\t}\n\t \t}\n\t\treturn (\n\t\t\t<div id=\"speakerList\">\n\t\t\t\tSpeakers: <ul>{speaker_list}</ul>\n\t\t\t</div>\n\t\t);\n\t} else {\n\t\treturn null;\n\t}\n}","export function Metadata({ metadata }) {\n\t// I/P: metadata, in JSON format\n\t// O/P: a nice display of speaker names + other metadata\n\t// Status: finished\n\tlet description = null;\n\tlet author = null;\n\tlet genre = null;\n\tlet date_created = null;\n\n\tif (metadata[\"description\"] != \"\") {\n\t\tdescription = <p><b>Description:</b> {metadata[\"description\"]}</p>;\n\t}\n\n\tif (metadata[\"author\"] != \"\") {\n\t\tauthor = <p>Author: {metadata[\"author\"]}</p>;\n\t}\n\n\tif (metadata[\"genre\"] != \"\") {\n\t\tgenre = <p>Genre: {metadata[\"genre\"]}</p>;\n\t}\n\n\tif (metadata[\"date_created\"] != \"\") {\n\t\tdate_created = <p>Date: {metadata[\"date_created\"]}</p>;\n\t}\n\n\treturn (\n\t\t<div id=\"metadata\">\n\t\t\t{description}\n\t\t\t{author}\n\t\t</div>\n\t);\n}\n\nexport function MoreMetadata({ metadata }) {\n\t// I/P: metadata, in JSON format\n\t// O/P: glosser + source information\n\t// Status: finished\n\tlet glosser = null;\n\tlet source = null;\n\n\n\tif (metadata[\"glosser\"] != \"\") {\n\t\tglosser = <p>Glosser: {metadata[\"glosser\"]}</p>;\n\t}\n\n\tif (metadata[\"source\"][\"_default\"] != \"\") {\n\t\tsource = <p>Source: {metadata[\"source\"][\"_default\"]}</p>;\n\t} else if (metadata[\"source\"].hasOwnProperty(\"con-Latn-EC\") && metadata[\"source\"][\"con-Latn-EC\"] != \"\") {\n\t\tsource = <p>Source: {metadata[\"source\"][\"con-Latn-EC\"]}</p>;\n\t}\n\n\treturn (\n\t\t<div id=\"metadata\">\n\t\t\t{source}\n\t\t\t{glosser}\n\t\t</div>\n\t);\n}","import { SpeakerInfo } from './SpeakerInfo.jsx';\nimport { Metadata } from './Metadata.jsx';\nimport { MoreMetadata } from './Metadata.jsx';\n\nexport function Info({ metadata }) {\n\t// I/P: metadata, in JSON format\n\t// O/P: a nice display of speaker names + other metadata\n\t// Status: finished\n\treturn (\n\t\t<div id=\"info\" className=\"miniPage active\">\n\t\t\t<Metadata metadata={metadata} />\n\t\t\t<SpeakerInfo speakers={metadata['speaker IDs']} />\n\t\t</div>\n\t);\n}\n\nexport function MoreInfo({ metadata }) {\n\t// I/P: metadata, in JSON format\n\t// O/P: glossing and source information\n\t// Status: finished\n\treturn (\n\t\t<div id=\"info\" className=\"miniPage active\">\n\t\t\t<MoreMetadata metadata={metadata} />\n\t\t</div>\n\t);\n}","import React from 'react'\nimport $ from 'jquery'\nclass TierCheckbox extends React.Component {\n   // I/P: tier_id, a string like \"T1\" or \"T15\"\n   //    tier_name, a string like \"English Morphemes\"\n   // O/P: a checkbox with the ability to hide/show elements with tier-data={tier_id}\n   // Status: tested, working\n   constructor(props) {\n      super(props);\n      this.state = {\n         checkboxState: true\n      };\n      this.toggle = this.toggle.bind(this);\n   }\n\n   toggle(event) {\n      this.setState({checkboxState: !this.state.checkboxState});\n\n      if (this.state.checkboxState) {\n         $(\"tr[data-tier='\" + this.props.tier_id + \"']\").css('display', 'none');\n      } else {\n         $(\"tr[data-tier='\" + this.props.tier_id + \"']\").css('display', 'table-row');\n      }\n   }\n\n   render() {\n      const tier_id = this.props.tier_id;\n      const tier_name = this.props.tier_name;\n      return (\n         <li>\n            <input type=\"checkbox\" onClick={this.toggle} defaultChecked />\n            <label>{tier_name}</label>\n         </li>\n      );\n   }\n}\n\nexport function TierCheckboxList({ tiers }) {\n   // I/P: tiers, a hashmap from Tier IDs to their names\n   // O/P: an unordered list of TierCheckboxes\n   // Status: tested, working\n   let output = [];\n   for (const tier_id in tiers) {\n      if (tiers.hasOwnProperty(tier_id)) {\n         output.push(<TierCheckbox key={tier_id} tier_id={tier_id} tier_name={tiers[tier_id]['name']} />);\n      }\n   }\n   return <div id=\"tierList\"><b>Show/hide tiers:</b> <ul>{output}</ul></div>;\n}","import { TierCheckboxList } from './TierCheckboxList.jsx';\nimport { Video } from './../../Video.jsx';\nimport React from 'react'\n\nclass VideoButton extends React.Component {\n  // I/P: --\n  // O/P: a button that can show/hide video, reset \"player\" ID, etc.\n  // Status: tested, working\n  constructor(props) {\n    super(props);\n    this.state = {\n      checkboxState: true\n    };\n    this.toggle = this.toggle.bind(this);\n  }\n\n  toggle(event) {\n    this.setState({checkboxState: !this.state.checkboxState});\n\n    if (!this.state.checkboxState) {\n      Video.show();\n    } else {\n      Video.hide();\n    }\n  }\n\n  render() {\n    return <div id=\"videoButton\"><input type=\"checkbox\" onClick={this.toggle} defaultChecked /><label>Show video</label></div>;\n  }\n}\n\nexport function Settings({ tiers, hasVideo }) {\n\t// I/P: tiers, a hashmap from Tier ID to {name, subdivided}\n\t//      hasVideo, a boolean\n\t// O/P: a search bar with concordance functionality\n\t// Status: untested\n  let videoButton = null;\n  if (hasVideo) {\n    videoButton = <VideoButton />;\n  }\n\n\treturn (\n\t\t<div id=\"settings\" className=\"miniPage\">\n\t\t\t<TierCheckboxList tiers={tiers} />\n\t\t\t{videoButton}\n\t\t</div>\n\t);\n}","import { Info } from './Info/Info.jsx';\nimport { MoreInfo } from './Info/Info.jsx';\nimport { Settings } from './Settings/Settings.jsx';\n\nexport function Minibar({ metadata, hasVideo }) {\n\t// I/P: metadata, in JSON format\n\t//      hasVideo, a boolean\n\t// O/P: description and tier checkboxes\n\t// Status: tested, working\n\n\treturn (\n\t\t<div id=\"minibar\">\n    \t\t<div id=\"miniPage\">\n\t    \t\t<Info metadata={metadata} />\n\t    \t\t<Settings tiers={metadata['tier IDs']} hasVideo={hasVideo} />\n\t    \t\t<MoreInfo metadata={metadata} />\n\t    \t</div>\n\t\t</div>\n\t);\n}","import { Title } from './Title.jsx';\nimport { Video } from './Video.jsx';\nimport { Minibar } from './Minibar/Minibar.jsx'\n\nexport function Sidebar({ metadata }) {\n\t// I/P: metadata, in JSON format\n\t// O/P: a sidebar complement to the TextDisplay\n\t// Status: untested\n\n\tlet title = metadata['title']['con-Latn-EC'];\n\tif (metadata['title']['_default'] != '') {\n\t\ttitle = metadata['title']['_default'];\n\t}\n\t\n\tif (metadata['timed'] && metadata['media']['video'] != '') {\n\t\tconst filename = metadata['media']['video'];\n\t\tconst path = filename;\n\t\treturn (\n\t\t\t<div id=\"leftPanel\">\n\t\t\t\t<Video path={path} />\n\t\t\t\t<Title title={title} />\n\t\t\t\t<Minibar metadata={metadata} hasVideo />\n\t\t\t</div>\n\t\t);\n\t} else {\n\t\treturn (\n\t\t\t<div id=\"leftPanel\">\n\t\t\t\t<Title title={title} />\n\t\t\t\t<Minibar metadata={metadata} hasVideo={false} />\n\t\t\t</div>\n\t\t);\n\t}\n}","import id from 'shortid';\n\nfunction Row({ numSlots, values, tier }) {\n\t// I/P: numSlots, taken from parent sentence\n\t//      values, list of segments (e.g., morphemes) with start/end times\n\t//      tier, the tier name\n\t// O/P: single row of glossed sentence, with colspan spacing\n\t// Status: tested, working\n\n\t// Building a row requires slots to determine the width of certain\n\t// table elements. Each element will have a start and end slot, and \n\t// if there is a gap between an end slot and the following start\n\t// slot, then a blank table element is input. We use the attribute\n\t// 'colSpan' to account for elements which require large slots.\n\n\t// The currentSlot counter is used to 'fill in' the missing\n\t// slots when a dependent tier doesn't line up with its corresponding\n\t// independent tier. For example, if the i-tier goes from 0-12, and\n\t// the dependent tier goes from 2-5 and 7-12, then the currentSlot\n\t// counter would be responsible for filling those gaps between 0-2\n\t// and 5-7.\n\tconst finalSlot = numSlots;\n\tlet currentSlot = 0;\n\tlet output = []; // Regular annotations.\n\n\tfor (const v of values) {\n\t\tconst startSlot = v['start_slot'];\n\t\tconst endSlot = v['end_slot'];\n\t\tconst text = v['value'];\n\n\t\t// Add blank space before current value:\n\t\tif (startSlot > currentSlot) {\n\t\t\tconst diff = String(startSlot - currentSlot);\n\t\t\toutput.push(<td key={id.generate()} colSpan={diff} />);\n\t\t}\n\t\t// Create element with correct 'colSpan' width:\n\t\tconst size = String(endSlot - startSlot);\n\t\t// if (size == numSlots) { // Add quotes to full-width lines\n\t\t// \toutput.push(<td key={id.generate()} colSpan={size}>{'\"' + text + '\"'}</td>);\n\t\t// } else {\n\t\t// \toutput.push(<td key={id.generate()} colSpan={size}>{text}</td>);\n\t\t// }\n\t\toutput.push(<td key={id.generate()} colSpan={size}>{text}</td>);\n\t\tcurrentSlot = endSlot;\n\t}\n\t// Fill blank space at end of table row:\n\tif (currentSlot < finalSlot) {\n\t\tconst diff = String(finalSlot - currentSlot);\n\t\toutput.push(<td key={id.generate()} colSpan={diff} />);\n\t}\n\treturn <tr data-tier={tier}>{output}</tr>;\n}\n\nexport function Sentence({ sentence }) {\n\t// I/P: sentence, a sentence\n\t// O/P: table of glossed Row components\n\t// Status: tested, working\n\tlet rowList = []; // to be output\n\t// let rowList2 = []; // full-length dependent tiers\n\tconst numSlots = sentence['num_slots'];\n\t// Add the indepentent tier, i.e., the top row, to the list of rows. Note that\n\t// 'colSpan={numSlots}' ensures that this row spans the entire table.\n  if (sentence['noTopRow'] == null || sentence['noTopRow'] === 'false') {\n    rowList.push(\n      <tr data-tier={sentence['tier']}>\n        <td colSpan={numSlots} className=\"topRow\">{sentence['text']}</td>\n      </tr>\n    );\n  }\n\tconst dependents = sentence['dependents']; // list of dependent tiers, flat structure\n\t// Add each dependent tier to the row list:\n\tfor (const {values, tier} of dependents) {\n\t\t// Tier attribute will be used for hiding/showing tiers:\n\t\t// if (values.length > 1) {\n\t\t// \trowList.push(<Row key={id.generate()} numSlots={numSlots} values={values} tier={tier} />);\n\t\t// } else {\n\t\t// \trowList2.push(<Row key={id.generate()} numSlots={numSlots} values={values} tier={tier} />);\n\t\t// }\n\t\trowList.push(<Row key={id.generate()} numSlots={numSlots} values={values} tier={tier} />);\n\t}\n\t// rowList = rowList.concat(rowList2);\n\treturn <table className=\"gloss\"><tbody>{rowList}</tbody></table>;\n}","import id from 'shortid';\nimport { Sentence } from \"./Sentence.jsx\";\n\nexport function UntimedTextDisplay({ sentences }) {\n\t// I/P: sentences, a list of sentences\n\t// O/P: the main gloss view, with several Sentences arranged vertically, each wrapped in an UntimedBlock\n\t// Status: tested, working\n\tlet output = [];\n\tfor (const sentence of sentences) {\n\t\toutput.push(\n\t\t\t<div key={id.generate()} className=\"untimedBlock\">\n\t\t\t\t<Sentence key={id.generate()} sentence={sentence} />\n\t\t\t</div>\n\t\t);\n\t}\n\treturn <div id=\"untimedTextDisplay\">{output}</div>;\n}","import * as fs from 'fs-web'\nexport function Apagar(){\n    const startTime = window.document.activeElement.getAttribute('capture-start-time');\n    const filho = window.document.activeElement.parentElement.parentElement\n    ApagarElement(filho)\n    ApagarTrilhanoJSON(startTime)\n}\n\nfunction ApagarElement(filho){\n    window.document.activeElement.parentElement.parentElement.parentElement.removeChild(filho)\n}\n\nfunction ApagarTrilhanoJSON(startTime){\n    console.log(startTime)\n    fs.readString('data/eaf_temp.json').then((data) => {\n        \n        let json = JSON.parse(data);\n        let cont=0;\n        let objTemp;\n        json.sentences.forEach(trilha => {\n            cont++;\n            if(trilha['start_time_ms'] == startTime){\n                objTemp = delete json.sentences[cont]\n                if(objTemp){\n                    cont=0;\n                    console.log(json.sentences)\n\n                }\n            }\n        });\n    })\n}","import id from 'shortid';\nimport { Sentence } from './Sentence.jsx';\nimport { Apagar } from './Apagar.jsx';\n\n\n\nfunction LabeledSentence({ sentence }) {\n\t// I/P: sentence, a sentence\n\t// O/P: glossed sentence with speaker label\n\t// Status: tested, working\n\tconst label = sentence['speaker'];\n\treturn (\n\t\t<div className=\"labeledSentence\">\n\t\t\t<span className=\"speakerLabel\">{label}: </span>\n\t\t\t<Sentence sentence={sentence} isTimeAligned />\n\t\t</div>\n\t);\n}\n\nfunction TimeBlock({ sentences }) {\n\t// I/P: sentences, a list of sentences with the same start time\n\t// O/P: div containing multiple LabeledSentences\n\t// Status: tested, working\n\tlet output = [];\n\t// A timeblock may contain multiple sentences with the same start time.\n\t// Iterate through the list of these sentences.\n\tfor (const sentence of sentences) {\n\t\toutput.push(<LabeledSentence key={id.generate()} sentence={sentence} />);\n\t}\n\treturn <div className=\"timeBlock\">{output}</div>;\n}\n\nfunction printSeconds(r) {\n\t// I/P: an integer number of seconds\n\t// O/P: time interval in h:mm:s or m:ss format (a string)\n\t// Status: tested, working\n\tr=Number(r);var t=Math.floor(r/3600),i=Math.floor(r%3600/60),n=Math.floor(r%3600%60);if(n>=10)e=String(n);else var e=\"0\"+String(n);var o=String(i)+\":\";if(0==t)a=\"\";else if(i>=10)a=String(t)+\":\";else var a=String(t)+\":0\";return a+o+e;\n}\n\nfunction LabeledTimeBlock({ sentences, timestamp }) {\n\t// I/P: sentences, a list of sentences with the same start time\n\t//      timestamp, an integer number of seconds\n\t// O/P: a TimeBlock with a left-floating timestamp\n\t// Status: tested, working\n\ttimestamp = printSeconds(timestamp);\n\t// Return the actual start and end time of this block in ms. Note that end times may differ,\n\t// so take the latest endtime of any sentence in this timeblock. These will be used in attributes\n\t// to render the current block in time with audio/video.\n\tlet minStart = Number.POSITIVE_INFINITY;\n\tlet maxEnd = Number.NEGATIVE_INFINITY;\n\tfor (const sentence of sentences) {\n\t\tconst startTime = sentence[\"start_time_ms\"];\n\t\tconst endTime = sentence[\"end_time_ms\"];\n\t\tif (startTime < minStart) {\n\t\t\tminStart = startTime;\n\t\t}\n\t\tif (endTime > maxEnd) {\n\t\t\tmaxEnd = endTime;\n\t\t}\n\t}\n\t\n\treturn (\n\t\t<div className=\"labeledTimeBlock\" data-start_time={minStart} data-end_time={maxEnd}>\n\t\t\t<span className=\"timeStampContainer\">\n\t\t\t\t<a href=\"javascript:void(0)\" data-start_time={minStart} className=\"timeStamp\">\n\t\t\t\t\t{timestamp}\n\t\t\t\t</a>\n\t\t\t\t<button capture-start-time={minStart} onClick={Apagar}>Delete</button>\n\t\t\t\t\n\t\t\t</span>\n\t\t\t<TimeBlock sentences={sentences} />\n\t\t</div>\n\t);\n}\n\nexport function TimedTextDisplay({ sentences }) {\n\t// I/P: sentences, stored in JSON format, as in test_data.json\n\t// O/P: the main gloss view, with several LabeledTimeBlocks arranged vertically\n\t// Status: tested, working\n\t// Note: very dependent on correct formatting of data\n\tlet output = [];\n\n\t// Steps to create ordered, unique TimeBlocks:\n\t//  1) Create a hashmap from start_times (in sec) to lists of sentences\n\t//  2) Sort the keys of this hashmap (stored in uniqueTimestamps)\n\t//  3) Each key-value pair corresponds to a unique TimeBlock\n\n\tlet timesToSentences = {}; // hashmap from timestamps (in sec) to lists of sentences\n\tlet uniqueTimestamps = []; // for sorting keys\n\tfor (const sentence of sentences) {\n\t\tconst timestampMs = sentence['start_time_ms'];\n\t\tconst timestampSec = Math.floor(timestampMs / 1000); // msec -> sec\n\t\tif (timestampSec in timesToSentences) {\n\t\t\ttimesToSentences[timestampSec].push(sentence);\n\t\t} else {\n\t\t\tuniqueTimestamps.push(timestampSec);\n\t\t\ttimesToSentences[timestampSec] = [sentence];\n\t\t}\n\t}\n\tuniqueTimestamps.sort((a, b) => a - b); // to avoid alphanumeric sorting\n\tfor (const timestamp of uniqueTimestamps) {\n\t\tconst correspondingSentences = timesToSentences[timestamp];\n\t\toutput.push(\n\t\t\t<LabeledTimeBlock \n\t\t\t\tkey={id.generate()} \n\t\t\t\tsentences={correspondingSentences} \n\t\t\t\ttimestamp={timestamp} \n\t\t\t/>\n\t\t);\n\t}\n\t\n\treturn <div id=\"timedTextDisplay\">{output}</div>;\n}","import { UntimedTextDisplay } from './Untimed.jsx';\nimport { TimedTextDisplay } from './Timed.jsx';\n\nexport function CenterPanel({ timed, sentences }) {\n\t// I/P: timed, a boolean value\n\t//      sentences, a list of sentences\n\t// O/P: the main panel showing glossing, timestamps, etc.\n\t// Status: tested, working\n\n\tif (timed) {\n\t\treturn <div id=\"centerPanel\"><TimedTextDisplay sentences={sentences} /></div>;\n\t} else {\n\t\treturn <div id=\"centerPanel\"><UntimedTextDisplay sentences={sentences} /></div>;\n\t}\n}","import $ from 'jquery'\n// Based on http://community.village.virginia.edu/etst/\n\nexport function setupTextSync() {\n    function scrollIntoViewIfNeeded(target) {\n        var rect = target.getBoundingClientRect();\n        if (rect.bottom > window.innerHeight) {\n            target.scrollIntoView(false);\n        }\n        if (rect.top < 0) {\n            target.scrollIntoView();\n        } \n    }\n\n    window.sync = function sync(current_time) {\n        for (var i=0; i<ts_tag_array.length; i++) {\n            // Somewhat hacky solution: decrease current_time by 0.001 to avoid highlighting before player starts\n            if ((current_time-0.001 >= parseFloat(ts_start_time_array[i])/1000.0) && (current_time <= parseFloat(ts_stop_time_array[i])/1000.0)) {\n                ts_tag_array[i].setAttribute(\"id\", \"current\");\n                // $('#example, #td').animate({scrollTop:$(\"#current\").offset().top}, 500);\n                scrollIntoViewIfNeeded($(\"#current\")[0]);\n                ts_tag_array[i].style.backgroundColor = \"rgb(209, 200, 225)\";\n            }\n            else {\n                ts_tag_array[i].style.backgroundColor = \"transparent\";\n                try { ts_tag_array[i].removeAttribute(\"id\"); }\n                catch (err) { }\n            }\n        }\n    }\n\n    try {\n        var media = document.querySelectorAll(\"[data-live='true']\")[0];\n        media.setAttribute(\"ontimeupdate\", \"sync(this.currentTime)\");\n        media.setAttribute(\"onclick\", \"sync(this.currentTime)\");\n    } catch (err) {\n        console.log(err);\n    }\n\n    const ts_tag_array = document.getElementsByClassName(\"labeledTimeBlock\");\n    const ts_start_time_array = [];\n    const ts_stop_time_array = [];\n\n    for (var i = 0; i < ts_tag_array.length; i++) {\n        ts_start_time_array[i] = ts_tag_array[i].getAttribute(\"data-start_time\");\n        ts_stop_time_array[i] = ts_tag_array[i].getAttribute(\"data-end_time\");\n    }\n    // }\n\n    // I/P: t, an integer number of milliseconds\n    // O/P: the player updates to the given time\n    // Status: untested\n    function jumpToTime(t) {\n        try {\n            t = t + 2;\n            media = document.querySelectorAll(\"[data-live='true']\")[0];\n            media.currentTime = t/1000;\n        }\n        catch(err) {\n            console.log(err);\n            console.log(\"We think you tried to jump to time before the MEDIA element was created.\")\n        }\n    }\n\n    $(\".timeStamp\").click(function() {\n        jumpToTime($(this).data('start_time'));\n    });\n}","import React from 'react'\nimport $ from 'jquery'\nimport { Sidebar } from './Sidebar/Sidebar.jsx';\nimport { CenterPanel } from './Display/CenterPanel.jsx';\nimport { Video } from './Sidebar/Video.jsx';\nimport { setupTextSync } from '../../js/txt_sync';\n\nexport class Story extends React.Component {\n    componentDidMount() {\n        // If there is a footer, i.e., if audio exists:\n        if ($('#footer').length !== 0) {\n            setupTextSync();\n            // If video exists:\n            if ($('#video').length !== 0) {\n                Video.show();\n            } else {\n                Video.hide();\n            }\n        }\n    }\n\n    render() {\n        const story = this.props.story;\n        console.log(story);\n        const sentences = story['sentences'];\n        const timed = (story['metadata']['timed']);\n        let footer = null;\n        if (timed) {\n            let audioFile;\n            const media = story['metadata']['media'];\n            if (media.hasOwnProperty('audio')) {\n                \n                audioFile = media['audio'];\n            } else {\n                audioFile = media['video'];\n            }\n            footer = <div id=\"footer\"><audio data-live=\"true\" controls controlsList=\"nodownload\" id=\"audio\" src={audioFile}/></div>;\n        }\n        return (\n            <div>\n                <div id=\"middle\">\n                    <Sidebar metadata={story['metadata']}/>\n                    <CenterPanel timed={timed} sentences={sentences}/>\n                </div>\n                {footer}\n            </div>\n        );\n    }\n}","import React, {Component} from 'react';\nimport * as fs from 'fs-web';\n\nconst initialState = {\n    participant: '',\n    trilha: '',\n    starttime: '',\n    endtime: ''\n}\n\nexport class Insert extends Component{\n    \n\n    constructor(props){\n        super(props)\n        this.state={\n            participant: '',\n            translations: '',\n            transcriptions: '',\n            starttime: '',\n            endtime: '',\n            sentence: null\n        };\n        this.captureInfo = this.captureInfo.bind(this)\n        this.verifyCompatibleWithLenghtOfMedia = this.verifyCompatibleWithLenghtOfMedia.bind(this)\n        this.setSentenceOnJSON = this.setSentenceOnJSON.bind(this)\n        this.writeFile = this.writeFile.bind(this)\n\n        this.handleChangeParticipant = this.handleChangeParticipant.bind(this);\n        this.handleChangeTranslations = this.handleChangeTranslations.bind(this);\n        this.handleChangeTranscriptions = this.handleChangeTranscriptions.bind(this);\n        this.handleChangeStartTime = this.handleChangeStartTime.bind(this);\n        this.handleChangeEndTime = this.handleChangeEndTime.bind(this);\n\n    }\n\n    captureInfo() {\n        console.log(this.state)\n        let sentence = '';\n        if(this.verifyCompatibleWithLenghtOfMedia()){\n            let json = this.props.story;\n            \n            json['speaker IDs']={\n                S1: {\n                    name: this.state.participant,\n                    tier: 'T1'\n                }\n            }\n            Array.of(json['speakers']).push(this.state.participant)\n            sentence = {\n                \"dependents\":[\n                    {\n                        \"tier\": \"T2\",\n                        \"values\": [\n                            {\n                                'value': this.state.translations,\n                                'end_slot': 1,\n                                'start_slot': 0\n                            }\n                        ]\n                    }\n                ], \n                \"end_time_ms\": this.state.endtime,\n                \"num_slots\": \"\",\n                \"speaker\": this.state.participant,\n                \"start_time_ms\": this.state.starttime,\n                \"text\": this.state.transcriptions,\n                \"tier\": \"T1\"\n            }\n            \n\n            console.log(sentence)\n            this.setSentenceOnJSON(sentence);\n\n            //reseta o state\n            this.setState(...initialState)\n            \n        }\n    }\n\n    verifyCompatibleWithLenghtOfMedia(){\n        let duration = document.getElementById('video')\n        if((duration.duration * 1000) > this.state.endtime){\n            console.log('Trilha compativel')\n            return true;\n        }\n    }\n\n    setSentenceOnJSON(sentence){\n         let json = this.props.story;\n         json.sentences.push(sentence)\n        // console.log(json)\n        // this.writeFile(json)\n        this.props.setJSONCallback(json);\n        \n    }\n\n    writeFile(json){\n        fs.writeFile(\"data/elan_files/eaftemp.eaf\", JSON.stringify(json, null, 2))\n    }\n\n    handleChangeParticipant(event){\n        this.setState({participant: event.target.value})\n    }\n\n    handleChangeTranslations(event){\n        this.setState({translations: event.target.value})\n    }\n\n    handleChangeTranscriptions(event){\n        this.setState({transcriptions: event.target.value})\n    }\n\n    handleChangeStartTime(event){\n        this.setState({starttime: event.target.value})\n    }\n\n    handleChangeEndTime(event){\n        this.setState({endtime: event.target.value})\n    }\n\n    render(){\n        return(\n            <div>\n                <div className=\"insert\" >\n                    <label className='labels participant' htmlFor=\"\">Participant</label>\n                    <input type=\"text\" className='participant' value={this.state.participant} onChange={this.handleChangeParticipant}/>\n\n                    <label className='labels starttime' htmlFor=\"\">Start Time</label>\n                    <input type=\"text\" className='starttime' value={this.state.starttime} onChange={this.handleChangeStartTime}/>\n\n                    <label className='labels endtime' htmlFor=\"\">End Time</label>\n                    <input type=\"text\" className='endtime' value={this.state.endTime} onChange={this.handleChangeEndTime}/>\n\n                    <label className='labels transcriptions' htmlFor=\"\">Transcriptions</label>\n                    <input type=\"text\" className='transcriptions' value={this.state.transcriptions} onChange={this.handleChangeTranscriptions}/>\n\n                    <label className='labels translations' htmlFor=\"\">Translations</label>\n                    <input type=\"text\" className='translations' value={this.state.translations} onChange={this.handleChangeTranslations}/>\n\n                    <input type=\"Submit\" id=\"submit\" className=\"add\" value=\"Add\" onClick={this.captureInfo} />\n                </div>\n                <div className=\"line\"></div>\n\n            </div>\n        )\n    }\n}\n\n","import React from 'react';\n\nexport function NotFound() {\n  return (\n      <p>Story not found. Perhaps you mistyped the URL? </p>\n  );\n}","import React, {Component} from 'react';\nimport { Route, Switch } from 'react-router-dom';\nimport { Story } from './Story/Story.jsx';\nimport { Insert } from '../Stories/Story/Display/Insert.jsx';\nimport { NotFound } from './NotFound.jsx';\nimport * as fs from 'fs-web';\nimport '../components/OpenProject.css'\n\nconst parseXml = require('xml2js').parseString;\nconst elan = require('../preprocessing/preprocess_eaf');\n\nexport default class Stories extends Component{\n  constructor(props){\n    super(props);\n    this.fileInput = React.createRef();\n    this.media = React.createRef();\n    this.open_file = this.open_file.bind(this);\n    this.setJSON = this.setJSON.bind(this);\n    this.state = {\n      JSON: null,\n      fileLoadend: false,\n      media: null,\n      xml: null,\n      sentence: null\n    }\n  }\n\n  open_file(){\n    const ref = this;\n    var reader1 = new FileReader();\n    var reader2 = new FileReader();\n    \n    reader1.readAsText(this.fileInput.current.files[0])\n    reader1.onload = function(){\n      fs.writeFile(\"data/elan_files/eaftemp.eaf\", reader1.result);      \n    }\n\n    reader2.readAsDataURL(this.media.current.files[0])\n    reader2.onload= function(){\n        ref.setState({video: reader2.result})\n      \n    }\n\n    const nameFile = this.fileInput.current.files[0].name;\n    \n    fs.readString(\"data/elan_files/eaftemp.eaf\")\n      .then(function(res){\n        parseXml(res, function(err2, jsonData){\n          if (err2) throw err2;\n          const adoc = jsonData.ANNOTATION_DOCUMENT\n          console.log(adoc)\n          elan.preprocess(adoc, nameFile, function(value){console.log(value)});\n          console.log(\"sucesso\")\n\n          fs.readString(\"data/eaf_temp.json\")\n            .then((data) => {\n              let json = JSON.parse(data);\n              json['metadata']['media']['video']= ref.state.video\n              json['metadata']['media']['audio']= ref.state.audio\n              \n              ref.setState({\n                JSON: json,\n                fileLoadend: true\n              });\n            });\n          });\n        })\n          \n  }\n\n\n  setJSON(JSON){\n    this.setState({\n      JSON\n    })\n  }\n\n  render(){\n    const story = this.state.JSON;\n    \n    return (\n      this.state.fileLoadend ?\n      <Switch>\n        {\n              <div>\n                <Insert story={story} setJSONCallback={this.setJSON} />\n                <Story story={story} />\n              </div>          \n        }\n\t\t\t\t<Route component={NotFound} />\n      </Switch>\n          \n      :\n          <div className='openproject'>\n            <div className=\"line-center\">\n                    <div className=\"line line-right\"></div>\n                    <h1 className=\"line fs-18\">Choose the files XMLs and the of media!</h1>\n                    <div className=\"line line-left\"></div>\n            </div>\n            <form >\n              <label className=\"labels-open\" htmlFor=\"xml\">Choose XML</label>\n              <input type=\"file\" id=\"xml\" ref = {this.fileInput}/>\n              <label className=\"labels-open\" htmlFor=\"media\"> Choose media</label>\n              <input type=\"file\" id=\"media\" ref = {this.media}/>\n\n              <input type=\"submit\" className=\"start\" value=\"Start\" onClick={this.open_file}/>\n            </form>\n          </div>\n      \n  );\n}\n}","import React, {Component} from 'react';\n\nexport default class Export extends Component{\n    constructor(props){\n        super(props);\n    }\n\n    render(){\n        return (\n            <div className='export'>\n                <button>Export XML</button>\n            </div>\n        );\n    }\n}\n","import React, {Component} from 'react';\nimport * as fs from 'fs-web';\nimport { Insert } from '../Stories/Story/Display/Insert.jsx';\nimport { Story } from '../Stories/Story/Story.jsx'\nimport Export from '../Stories/Story/Display/Export.jsx'\nimport './NewProject.css'\n\n\nexport default class NewProject extends Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            JSON:null,\n            media: null,\n            \n\n        }\n        this.createJSON = this.createJSON.bind(this);\n        this.setJSON = this.setJSON.bind(this);\n        this.fileMedia = React.createRef();\n        this.loadFiles = this.loadFiles.bind(this);\n    }\n\n    createJSON(){\n        let json = \n        {\n            \"metadata\":{\n                \"author\": \"\",\n                \"timed\": true,\n                \"date_created\": new Date(),\n                \"data_uploaded\": \"\",\n                \"description\": \"\",\n                \"genre\": \"\",\n                \"glosser\": \"\",\n                \"languages\": [],\n                \"media\":{\n                    \"audio\": \"\",\n                    \"video\": this.state.media\n                },\n                \"source\":{\n                    \"_default\":\"\"\n                },\n                \"source_filetype\": \"ELAN\",\n                \"speaker IDs\":{},\n                \"speakers\":[],\n                \"story ID\": \"0ef60c73-c757-46c9-ab12-a17874de63ee\",\n                \"tier IDs\":{\n                    \"T1\": {\n                        \"name\": \"Transcriptions\",\n                        \"subdivided\": false\n                    },\n                    \"T2\": {\n                        \"name\": \"Translations\",\n                        \"subdivided\": \"false\"\n                    }\n                },\n                \"timed\":true,\n                \"title\":{\n                    \"_default\":\"\"\n                }\n            },\n\n            \"sentences\": []\n        }\n        this.setState({JSON: json})\n        console.log(json)\n    }\n\n    loadFiles(){\n        const ref = this;\n        \n        var reader = new FileReader();\n        \n        reader.readAsDataURL(this.fileMedia.current.files[0])\n        reader.onload= function(){\n            ref.setState({media: reader.result})\n            if(ref.fileMedia.current.files[0].type.includes('video'))\n                console.log(\"video\")\n            else if(ref.fileMedia.current.files[0].type.includes('audio'))\n                console.log(\"audio\")\n            ref.createJSON()\n            \n        }\n        \n    }\n    \n    setJSON(JSON){\n        this.setState({\n          JSON\n        })\n    }\n\n    render(){\n\n        const story = this.state.JSON;\n        console.log(story)\n        return(\n            this.state.JSON ? \n            <div>\n                <Insert story={story} setJSONCallback={this.setJSON} />\n                <Export />\n                <Story story={this.state.JSON}/>\n            </div>\n            :\n\n            <div className='form'>\n                <div className=\"line-center\">\n\n                    <div className=\"line line-right\"></div>\n                    <h1 className=\"line fs-18\">Choose the file of Media</h1>\n                    <div className=\"line line-left\"></div>\n                </div>\n                <div className=\"start-button\" >\n                    <label htmlFor=\"arquivo\" className='xml'>Choose a Media</label>\n                    <input type=\"file\" id=\"file-here\" ref={this.fileMedia} onInput={this.loadFiles} id=\"arquivo\"/>\n                </div>\n            </div>\n        )\n    }\n}","import React, {Component} from 'react';\nimport './Home.css'\n\nexport default class Home extends Component{\n    constructor(props){\n        super(props)\n    }\n\n    render(){\n        return(\n            <div className=\"home\">\n                <div className=\"descr\">\n                    <div className=\"line-title\"></div>\n                        <h2 className=\"subtitle\">Laws  uma ferramenta computacional para anotaes lingusticas manuais de arquivos audiovisuais!</h2>\n                    <div className=\"line-title\"></div>\n                    \n                </div>\n                <div className=\"descr\">\n                    <h3 className=\"sub-desc\">Plataforma amigavel e simples para todos os pblicos</h3>\n                </div>\n                <div className='view'>\n                <h2>View</h2>\n                </div>\n                <div>\n\n                </div>\n\n            </div>\n        );\n    }\n}","import React from 'react';\nimport { Route } from 'react-router-dom';\nimport  Stories  from './Stories/Stories.jsx';\nimport  NewProject  from './components/NewProject.jsx';\nimport  Home  from './components/Home.jsx';\nimport './App.css'\n\nexport function App() {\n    return (\n        <div>\n            <Route exact path=\"/\" render={props => <Home/>} />\n            <Route path=\"/stories\" render={props => <Stories/>}/>\n            <Route exact path=\"/newproject\" render={props => <NewProject/>}/>\n        </div>\n    );\n}","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { HashRouter as Router } from 'react-router-dom';\n// import './index.css';\nimport {App} from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <Router>\n    <App />\n  </Router>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}