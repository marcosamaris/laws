[{"/home/kalebe/Projects/laws/src/index.js":"1","/home/kalebe/Projects/laws/src/reportWebVitals.js":"2","/home/kalebe/Projects/laws/src/App.jsx":"3","/home/kalebe/Projects/laws/src/components/Home.jsx":"4","/home/kalebe/Projects/laws/src/components/NewProject.jsx":"5","/home/kalebe/Projects/laws/src/Stories/Stories.jsx":"6","/home/kalebe/Projects/laws/src/Stories/NotFound.jsx":"7","/home/kalebe/Projects/laws/src/Stories/Story/Display/Export.jsx":"8","/home/kalebe/Projects/laws/src/Stories/Story/Story.jsx":"9","/home/kalebe/Projects/laws/src/Stories/Story/Display/Insert.jsx":"10","/home/kalebe/Projects/laws/src/Stories/Story/Display/CenterPanel.jsx":"11","/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Sidebar.jsx":"12","/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Video.jsx":"13","/home/kalebe/Projects/laws/src/preprocessing/preprocess_eaf.js":"14","/home/kalebe/Projects/laws/src/js/txt_sync.js":"15","/home/kalebe/Projects/laws/src/Stories/Story/Display/Untimed.jsx":"16","/home/kalebe/Projects/laws/src/Stories/Story/Display/Timed.jsx":"17","/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Title.jsx":"18","/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Minibar/Minibar.jsx":"19","/home/kalebe/Projects/laws/src/Stories/Story/Display/Apagar.jsx":"20","/home/kalebe/Projects/laws/src/Stories/Story/Display/Sentence.jsx":"21","/home/kalebe/Projects/laws/src/preprocessing/pfsx_utils.js":"22","/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Minibar/Info/Info.jsx":"23","/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Minibar/Settings/Settings.jsx":"24","/home/kalebe/Projects/laws/src/preprocessing/eaf_utils.js":"25","/home/kalebe/Projects/laws/src/preprocessing/helper_functions.js":"26","/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Minibar/Info/Metadata.jsx":"27","/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Minibar/Info/SpeakerInfo.jsx":"28","/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Minibar/Settings/TierCheckboxList.jsx":"29","/home/kalebe/Projects/laws/src/preprocessing/flex_utils.js":"30"},{"size":542,"mtime":1610557955091,"results":"31","hashOfConfig":"32"},{"size":362,"mtime":1610538443022,"results":"33","hashOfConfig":"32"},{"size":517,"mtime":1610557640126,"results":"34","hashOfConfig":"32"},{"size":916,"mtime":1610648959047,"results":"35","hashOfConfig":"32"},{"size":3505,"mtime":1611019989878,"results":"36","hashOfConfig":"32"},{"size":3274,"mtime":1610726941474,"results":"37","hashOfConfig":"32"},{"size":135,"mtime":1610106129547,"results":"38","hashOfConfig":"32"},{"size":291,"mtime":1610106129547,"results":"39","hashOfConfig":"32"},{"size":1564,"mtime":1610557671307,"results":"40","hashOfConfig":"32"},{"size":4995,"mtime":1610805728544,"results":"41","hashOfConfig":"32"},{"size":505,"mtime":1610106129547,"results":"42","hashOfConfig":"32"},{"size":833,"mtime":1610106129548,"results":"43","hashOfConfig":"32"},{"size":2218,"mtime":1610547734354,"results":"44","hashOfConfig":"32"},{"size":23416,"mtime":1610556550764,"results":"45","hashOfConfig":"32"},{"size":2499,"mtime":1610555816765,"results":"46","hashOfConfig":"32"},{"size":549,"mtime":1610106129548,"results":"47","hashOfConfig":"32"},{"size":4001,"mtime":1610106129548,"results":"48","hashOfConfig":"32"},{"size":149,"mtime":1610106129548,"results":"49","hashOfConfig":"32"},{"size":549,"mtime":1610106129548,"results":"50","hashOfConfig":"32"},{"size":950,"mtime":1610106129547,"results":"51","hashOfConfig":"32"},{"size":3396,"mtime":1610106129547,"results":"52","hashOfConfig":"32"},{"size":1415,"mtime":1610106129550,"results":"53","hashOfConfig":"32"},{"size":699,"mtime":1610106129548,"results":"54","hashOfConfig":"32"},{"size":1173,"mtime":1610547652806,"results":"55","hashOfConfig":"32"},{"size":9407,"mtime":1610106129549,"results":"56","hashOfConfig":"32"},{"size":10585,"mtime":1610556117420,"results":"57","hashOfConfig":"32"},{"size":1321,"mtime":1610106129548,"results":"58","hashOfConfig":"32"},{"size":736,"mtime":1610106129548,"results":"59","hashOfConfig":"32"},{"size":1537,"mtime":1610547705066,"results":"60","hashOfConfig":"32"},{"size":5166,"mtime":1610106129549,"results":"61","hashOfConfig":"32"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},"1g9ddd2",{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"64"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74","usedDeprecatedRules":"64"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"81","usedDeprecatedRules":"64"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"90","usedDeprecatedRules":"64"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"95","usedDeprecatedRules":"64"},{"filePath":"96","messages":"97","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"98","messages":"99","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"100","messages":"101","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"102","usedDeprecatedRules":"64"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"105","messages":"106","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"107","messages":"108","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"109","usedDeprecatedRules":"64"},{"filePath":"110","messages":"111","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"112","messages":"113","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"114","usedDeprecatedRules":"64"},{"filePath":"115","messages":"116","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"117","messages":"118","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"119","messages":"120","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"121","usedDeprecatedRules":"64"},{"filePath":"122","messages":"123","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"124","usedDeprecatedRules":"64"},{"filePath":"125","messages":"126","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"127","usedDeprecatedRules":"64"},{"filePath":"128","messages":"129","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"130","messages":"131","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"132","usedDeprecatedRules":"64"},{"filePath":"133","messages":"134","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"135"},"/home/kalebe/Projects/laws/src/index.js",[],["136","137"],"/home/kalebe/Projects/laws/src/reportWebVitals.js",[],"/home/kalebe/Projects/laws/src/App.jsx",[],"/home/kalebe/Projects/laws/src/components/Home.jsx",["138"],"import React, {Component} from 'react';\nimport './Home.css'\n\nexport default class Home extends Component{\n    constructor(props){\n        super(props)\n    }\n\n    render(){\n        return(\n            <div className=\"home\">\n                <div className=\"descr\">\n                    <div className=\"line-title\"></div>\n                        <h2 className=\"subtitle\">Laws é uma ferramenta computacional para anotações linguísticas manuais de arquivos audiovisuais!</h2>\n                    <div className=\"line-title\"></div>\n                    \n                </div>\n                <div className=\"descr\">\n                    <h3 className=\"sub-desc\">Plataforma amigavel e simples para todos os públicos</h3>\n                </div>\n                <div className='view'>\n                <h2>View</h2>\n                </div>\n                <div>\n\n                </div>\n\n            </div>\n        );\n    }\n}","/home/kalebe/Projects/laws/src/components/NewProject.jsx",["139","140","141"],"import React, {Component} from 'react';\nimport * as fs from 'fs-web';\nimport { Insert } from '../Stories/Story/Display/Insert.jsx';\nimport { Story } from '../Stories/Story/Story.jsx'\nimport Export from '../Stories/Story/Display/Export.jsx'\nimport './NewProject.css'\n\n\nexport default class NewProject extends Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            JSON:null,\n            media: null,\n            \n\n        }\n        this.createJSON = this.createJSON.bind(this);\n        this.setJSON = this.setJSON.bind(this);\n        this.fileMedia = React.createRef();\n        this.loadFiles = this.loadFiles.bind(this);\n    }\n\n    createJSON(){\n        let json = \n        {\n            \"metadata\":{\n                \"author\": \"\",\n                \"timed\": true,\n                \"date_created\": new Date(),\n                \"data_uploaded\": \"\",\n                \"description\": \"\",\n                \"genre\": \"\",\n                \"glosser\": \"\",\n                \"languages\": [],\n                \"media\":{\n                    \"audio\": \"\",\n                    \"video\": this.state.media\n                },\n                \"source\":{\n                    \"_default\":\"\"\n                },\n                \"source_filetype\": \"ELAN\",\n                \"speaker IDs\":{},\n                \"speakers\":[],\n                \"story ID\": \"0ef60c73-c757-46c9-ab12-a17874de63ee\",\n                \"tier IDs\":{\n                    \"T1\": {\n                        \"name\": \"Transcriptions\",\n                        \"subdivided\": false\n                    },\n                    \"T2\": {\n                        \"name\": \"Translations\",\n                        \"subdivided\": \"false\"\n                    }\n                },\n                \"timed\":true,\n                \"title\":{\n                    \"_default\":\"\"\n                }\n            },\n\n            \"sentences\": []\n        }\n        this.setState({JSON: json})\n        console.log(json)\n    }\n\n    loadFiles(){\n        const ref = this;\n        \n        var reader = new FileReader();\n        \n        reader.readAsDataURL(this.fileMedia.current.files[0])\n        reader.onload= function(){\n            ref.setState({media: reader.result})\n            if(ref.fileMedia.current.files[0].type.includes('video'))\n                console.log(\"video\")\n            else if(ref.fileMedia.current.files[0].type.includes('audio'))\n                console.log(\"audio\")\n            ref.createJSON()\n            \n        }\n        \n    }\n    \n    setJSON(JSON){\n        this.setState({\n          JSON\n        })\n    }\n\n    render(){\n\n        const story = this.state.JSON;\n        console.log(story)\n        return(\n            this.state.JSON ? \n            <div>\n                <Insert story={story} setJSONCallback={this.setJSON} />\n                <Export />\n                <Story story={this.state.JSON}/>\n            </div>\n            :\n\n            <div className='form'>\n                <div className=\"line-center\">\n\n                    <div className=\"line line-right\"></div>\n                    <h1 className=\"line fs-18\">Choose the file of Media</h1>\n                    <div className=\"line line-left\"></div>\n                </div>\n                <div className=\"start-button\" >\n                    <label htmlFor=\"arquivo\" className='xml'>Choose a Media</label>\n                    <input type=\"file\" id=\"file-here\" ref={this.fileMedia} onInput={this.loadFiles} id=\"arquivo\"/>\n                </div>\n            </div>\n        )\n    }\n}","/home/kalebe/Projects/laws/src/Stories/Stories.jsx",[],"/home/kalebe/Projects/laws/src/Stories/NotFound.jsx",[],"/home/kalebe/Projects/laws/src/Stories/Story/Display/Export.jsx",["142"],"import React, {Component} from 'react';\n\nexport default class Export extends Component{\n    constructor(props){\n        super(props);\n    }\n\n    render(){\n        return (\n            <div className='export'>\n                <button>Export XML</button>\n            </div>\n        );\n    }\n}\n","/home/kalebe/Projects/laws/src/Stories/Story/Story.jsx",[],"/home/kalebe/Projects/laws/src/Stories/Story/Display/Insert.jsx",[],"/home/kalebe/Projects/laws/src/Stories/Story/Display/CenterPanel.jsx",[],"/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Sidebar.jsx",["143","144"],"import { Title } from './Title.jsx';\nimport { Video } from './Video.jsx';\nimport { Minibar } from './Minibar/Minibar.jsx'\n\nexport function Sidebar({ metadata }) {\n\t// I/P: metadata, in JSON format\n\t// O/P: a sidebar complement to the TextDisplay\n\t// Status: untested\n\n\tlet title = metadata['title']['con-Latn-EC'];\n\tif (metadata['title']['_default'] != '') {\n\t\ttitle = metadata['title']['_default'];\n\t}\n\t\n\tif (metadata['timed'] && metadata['media']['video'] != '') {\n\t\tconst filename = metadata['media']['video'];\n\t\tconst path = filename;\n\t\treturn (\n\t\t\t<div id=\"leftPanel\">\n\t\t\t\t<Video path={path} />\n\t\t\t\t<Title title={title} />\n\t\t\t\t<Minibar metadata={metadata} hasVideo />\n\t\t\t</div>\n\t\t);\n\t} else {\n\t\treturn (\n\t\t\t<div id=\"leftPanel\">\n\t\t\t\t<Title title={title} />\n\t\t\t\t<Minibar metadata={metadata} hasVideo={false} />\n\t\t\t</div>\n\t\t);\n\t}\n}","/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Video.jsx",[],"/home/kalebe/Projects/laws/src/preprocessing/preprocess_eaf.js",["145","146","147","148","149"],"const fs = require('fs-web');\n// const parseXml = require('xml2js').parseString;\n// const eafUtils = require('./eaf_utils');\nconst {getAlignableAnnotationStartSlot, \n  getAlignableAnnotationEndSlot, getDocID, \n  getNonemptyTiers, getParentTierName, \n  getTierName, isTierSubdivided,\n  getAnnotationValue, getAnnotations,\n  getAnnotationID, getAnnotationIDMap, \n  getDocTimeslotsMap, getTierSpeakerName, \n  getTierChildrenMap, getTierLanguage} = require('./eaf_utils')\n// const pfsxUtils = require('./pfsx_utils');\nconst pfsxUtils = require ('./pfsx_utils')\nconst helper = require('./helper_functions');\n\n// function updateIndex(indexMetadata, indexFileName, storyID) {\n//   let index = JSON.parse(fs.readFileSync(indexFileName, \"utf8\"));\n//   index[storyID] = indexMetadata;\n//   fs.writeFileSync(indexFileName, JSON.stringify(index, null, 2));\n// }\n\n// Stretch children to fill full duration of parent.\n// Specifically, if parent has P slots and child has C slots (incl gaps except final gap),\n// then increase the child's slots by a factor of P/C,\n// i.e., subtract parentStartSlot from everything, \n//   set each c in C to floor(c * (double) P / (double) C),\n//   and then add parentStartSlot back in. \nfunction scaledSlot(slotIn, parentStart, tierEnd, latestEnd) {\n  const parentLen = latestEnd - parentStart;\n  const childLen = tierEnd - parentStart;\n  let slot = slotIn - parentStart;\n  slot = Math.floor(slot * parentLen / childLen);\n  slot = slot + parentStart;\n  return slot;\n}\n\nfunction assignSlots(anotID, tiersToConstraints,\n    annotationChildren, annotationsFromIDs, timeslots, startSlots, endSlots) {\n  assignSlotsHelper(anotID, 0, tiersToConstraints,\n    annotationChildren, annotationsFromIDs, timeslots, startSlots, endSlots);\n  // At this point, startSlots and endSlots contain the smallest allowable slot value.\n  stretchSlots(anotID, 0, tiersToConstraints,\n    annotationChildren, annotationsFromIDs, timeslots, startSlots, endSlots);\n}\n\nfunction assignSlotsHelper(anotID, parentStartSlot, tiersToConstraints,\n    annotationChildren, annotationsFromIDs, timeslots, startSlots, endSlots) {\n  startSlots[anotID] = parentStartSlot;\n  let latestEndSlot = parentStartSlot + 1;\n  for (const depTierName in annotationChildren[anotID]) {\n    if (annotationChildren[anotID].hasOwnProperty(depTierName)) {\n      let slotNum = parentStartSlot;\n      \n      let prevTimeslot = null; // used for detecting gaps\n      let maybeGaps = (tiersToConstraints[depTierName] === 'Included_In');\n      if (maybeGaps) {\n        prevTimeslot = getAlignableAnnotationStartSlot(annotationsFromIDs[anotID]);\n      }\n      \n      const depAnotIDs = annotationChildren[anotID][depTierName];\n      for (var depAnotID of depAnotIDs) {\n        if (maybeGaps) {\n          const startTimeslot = getAlignableAnnotationStartSlot(annotationsFromIDs[depAnotID]);\n          if (startTimeslot !== prevTimeslot \n            && timeslots[startTimeslot] !== timeslots[prevTimeslot]) {\n            slotNum++;  \n          }\n          prevTimeslot = getAlignableAnnotationEndSlot(annotationsFromIDs[depAnotID]);\n        }\n        \n        assignSlotsHelper(depAnotID, slotNum, tiersToConstraints, annotationChildren, \n            annotationsFromIDs, timeslots, startSlots, endSlots);\n        slotNum = endSlots[depAnotID];\n        latestEndSlot = Math.max(latestEndSlot, slotNum);\n      }\n    }\n  }\n  \n  // make parent's end slot at least as late as its child's\n  endSlots[anotID] = latestEndSlot;\n}\n\n// Stretch children to fill full duration of parent.\n// prevStretch: the total increase in the parent's startslot due to stretch\nfunction stretchSlots(anotID, prevStretch, tiersToConstraints,\n    annotationChildren, annotationsFromIDs, timeslots, startSlots, endSlots) {\n  for (const depTierName in annotationChildren[anotID]) {\n    if (annotationChildren[anotID].hasOwnProperty(depTierName)) {\n      const depAnotIDs = annotationChildren[anotID][depTierName];\n      const tierEnd = endSlots[depAnotIDs[depAnotIDs.length - 1]] + prevStretch;\n      const parentStart = startSlots[anotID];\n      const parentEnd = endSlots[anotID];\n      for (var depAnotID of depAnotIDs) {\n        const origStart = startSlots[depAnotID];\n        const newStart = scaledSlot(origStart + prevStretch, parentStart, tierEnd, parentEnd);\n        startSlots[depAnotID] = newStart;\n        const scaledEnd = scaledSlot(endSlots[depAnotID] + prevStretch, parentStart, tierEnd, parentEnd);\n        endSlots[depAnotID] = scaledEnd;\n        stretchSlots(depAnotID, newStart - origStart, tiersToConstraints, \n            annotationChildren, annotationsFromIDs, timeslots, startSlots, endSlots);\n      }\n    }\n  }\n}\n\nfunction preprocess(adocIn, pfsxIn, xmlFileName, callback) {\n  const storyID = getDocID(adocIn);\n  const indexMetadata = helper.improveElanIndexData(xmlFileName, storyID, adocIn);\n  //updateIndex(indexMetadata, \"data/index.json\", storyID);\n  //updateIndex(indexMetadata, \"data/index.json\", storyID);\n  const jsonOut = {\n    \"metadata\": indexMetadata,\n    \"sentences\": []\n  };\n  jsonOut.metadata[\"tier IDs\"] = {};\n  jsonOut.metadata[\"speaker IDs\"] = {};\n  jsonOut.metadata[\"story ID\"] = storyID; // TODO is this needed?\n\n  const tiers = getNonemptyTiers(adocIn);\n  const indepTiers = tiers.filter((tier) => getParentTierName(tier) == null);\n  \n  // give each tier an ID\n  let tierIDsFromNames = {};\n  for (let i = 0; i < tiers.length; i++) {\n    const newID = \"T\" + (i + 1).toString();\n    const tier = tiers[i];\n    const tierName = getTierName(tier);\n    jsonOut.metadata[\"tier IDs\"][newID] = {\n      name: tierName,\n      subdivided: isTierSubdivided(tierName, tiers),\n    };\n    tierIDsFromNames[tierName] = newID;\n  }\n  \n  // TODO glom morphs if coming from FLEx?\n  \n  // tiersToConstraints: tierName -> constraintName\n  // (to generate, first create typesToConstraints: linguisticTypeName -> constraintName)\n  const typesToConstraints = {};\n  const linguisticTypes = adocIn.LINGUISTIC_TYPE\n  for (const lingType of linguisticTypes) {\n    const lingTypeID = lingType.$.LINGUISTIC_TYPE_ID;\n    const constraintName = lingType.$.CONSTRAINTS || '';\n    typesToConstraints[lingTypeID] = constraintName;\n  }\n  const tiersToConstraints = {};\n  for (const tier of tiers) {\n    const tierName = getTierName(tier);\n    const linguisticType = tier.$.LINGUISTIC_TYPE_REF;\n    const constraintName = typesToConstraints[linguisticType];\n    tiersToConstraints[tierName] = constraintName;\n  }\n  // console.log(`tiersToConstraints: ${tiersToConstraints}`);\n  \n  const untimedTiers = tiers.filter(tier => \n    (tiersToConstraints[getTierName(tier)] === 'Symbolic_Subdivision' \n    || tiersToConstraints[getTierName(tier)] === 'Symbolic_Association')\n  );\n  \n  // annotationChildren: parentAnnotationID -> childTierName(very sparse) -> listof childAnnotationID\n  const annotationChildren = {};\n  for (const tier of untimedTiers) {\n    const childTierName = getTierName(tier);\n    // console.log(`adding untimed child tier ${childTierName} to annotationChildren`);\n    for (const annotation of getAnnotations(tier)) {\n      const childAnnotationID = getAnnotationID(annotation);\n      let parentAnnotationID = annotation.REF_ANNOTATION[0].$.ANNOTATION_REF; \n      \n      if (annotationChildren[parentAnnotationID] == null) {\n        annotationChildren[parentAnnotationID] = {}\n      }\n      if (annotationChildren[parentAnnotationID][childTierName] == null) {\n        annotationChildren[parentAnnotationID][childTierName] = [];\n      }\n      annotationChildren[parentAnnotationID][childTierName].push(childAnnotationID);\n    }\n  }\n  \n  const annotationsFromIDs = getAnnotationIDMap(tiers);\n  const timeslots = getDocTimeslotsMap(adocIn);\n  \n  // sort untimed children\n  for (const parentAnnotationID in annotationChildren) {\n    if (annotationChildren.hasOwnProperty(parentAnnotationID)) {\n      for (const childTierName in annotationChildren[parentAnnotationID]) {\n        const childIDs = annotationChildren[parentAnnotationID][childTierName];\n        let sortedChildIDs = [];\n        const constraint = tiersToConstraints[childTierName];\n        if (constraint === 'Symbolic_Association') { // 1-1 association\n          // assert childIDs.length === 1; \n          sortedChildIDs = childIDs;\n        } else if (constraint === 'Symbolic_Subdivision') { // untimed subdivision, ordered\n          let prev = '';\n          for (const id of childIDs) {\n            const cur = childIDs.find(a => \n              prev === (annotationsFromIDs[a].REF_ANNOTATION[0].$.PREVIOUS_ANNOTATION || '')\n            );\n            sortedChildIDs.push(cur);\n            prev = cur;\n          }\n        } else { // this should never happen\n          console.log(`WARNING: missing or unrecognized ELAN stereotype for tier ${childTierName}. Annotations may display out of order.`);\n          sortedChildIDs = childIDs;\n        }\n        \n        annotationChildren[parentAnnotationID][childTierName] = sortedChildIDs;\n      }\n    }\n  }\n  \n  const tierChildren = getTierChildrenMap(tiers);\n  \n  // add sorted 'Time_Subdivision' children\n  for (const parentTier of tiers) {\n    const childTierNames = tierChildren[getTierName(parentTier)] || [];\n    const timeSubdivChildTiers = tiers.filter(tier => \n      tiersToConstraints[getTierName(tier)] === 'Time_Subdivision'\n      && childTierNames.find(n => n === getTierName(tier)) != null\n    );\n    for (const childTier of timeSubdivChildTiers) {\n      const childTierName = getTierName(childTier);\n      // console.log(`adding time-subdiv child tier ${childTierName} to annotationChildren`);\n      const childTierAnots = getAnnotations(childTier);\n      for (const parentAnot of getAnnotations(parentTier)) {\n        const sortedChildIDs = [];\n        let prevSlot = getAlignableAnnotationStartSlot(parentAnot);\n        const endSlot = getAlignableAnnotationEndSlot(parentAnot);\n        while (prevSlot !== endSlot) {\n          /* partial procedural rewrite of find code: \n          let cur;\n          for (const childAnot of childAnots) {\n            const childSlot = getAlignableAnnotationStartSlot(childAnot);\n            if (prevSlot === childSlot) {\n              cur = childAnot;\n              \n            }\n          }*/\n          const cur = childTierAnots.find(a => \n            prevSlot === getAlignableAnnotationStartSlot(a) || \n            (timeslots[prevSlot] != null && \n            timeslots[prevSlot] === getAlignableAnnotationStartSlot(a)\n            )\n          );\n          if (cur == null) {\n            // this parent anot has no children on this tier\n            break; // exit the while loop\n          }\n          const curID = getAnnotationID(cur);\n          sortedChildIDs.push(curID);\n          prevSlot = getAlignableAnnotationEndSlot(cur);\n        }\n        \n        const parentAnotID = getAnnotationID(parentAnot);\n        if (sortedChildIDs.length !== 0) {\n          if (annotationChildren[parentAnotID] == null) {\n            annotationChildren[parentAnotID] = {}\n          }\n          annotationChildren[parentAnotID][childTierName] = sortedChildIDs;\n        }\n      }\n    }\n  }\n  \n  // add 'Included_In' children\n  for (const parentTier of tiers) {\n    const parentTierName = getTierName(parentTier);\n    const childTierNames = tierChildren[getTierName(parentTier)] || [];\n    const inclChildTiers = tiers.filter(tier => \n      tiersToConstraints[getTierName(tier)] === 'Included_In'\n      && childTierNames.find(n => n === getTierName(tier)) != null\n    );\n    for (const childTier of inclChildTiers) {\n      const childTierName = getTierName(childTier);\n      // console.log(`adding incl-in child tier ${childTierName} of ${parentTierName} to annotationChildren`);\n      const childTierAnots = getAnnotations(childTier);\n      for (const parentAnot of getAnnotations(parentTier)) {\n        let childIDs = [];\n        const parentStartSlot = getAlignableAnnotationStartSlot(parentAnot);\n        const parentEndSlot = getAlignableAnnotationEndSlot(parentAnot);\n        \n        const parentStartMs = timeslots[parentStartSlot];\n        const parentEndMs = timeslots[parentEndSlot];\n        if (parentStartMs && parentEndMs) { // get children within these ms values\n          // console.log(`within ms ${parentStartMs}, ${parentEndMs}?`);\n          for (var anot of childTierAnots) {\n            const anotID = getAnnotationID(anot);\n            const startSlot = getAlignableAnnotationStartSlot(anot);\n            const endSlot = getAlignableAnnotationEndSlot(anot);\n            // console.log(`  checking child ${anotID}, slots ${startSlot}, ${endSlot}`);\n            const startsWithin = (\n              timeslots[startSlot] >= parentStartMs \n              && timeslots[startSlot] < parentEndMs\n            );\n            const endsWithin = (\n              timeslots[endSlot] > parentStartMs \n              && timeslots[endSlot] <= parentEndMs\n            );\n            if (startsWithin || endsWithin) {\n              // console.log('  added!');\n              childIDs.push(anotID);\n            }\n          }\n          \n          // sort by ms value\n          childIDs = childIDs.sort((id1,id2) => {\n            // if start isn't defined, calculate it based on end, pretending duration is 1 ms\n            const a1 = annotationsFromIDs[id1];\n            const a2 = annotationsFromIDs[id2];\n            const start1 = (\n              timeslots[getAlignableAnnotationStartSlot(a1)]\n              || timeslots[getAlignableAnnotationEndSlot(a1)] - 1\n            );\n            const start2 = (\n              timeslots[getAlignableAnnotationStartSlot(a2)] \n              || timeslots[getAlignableAnnotationEndSlot(a2)] - 1\n            );\n            return start1 - start2;\n          });\n        }\n        \n        // check for children which share the parent's start or end slot\n        for (anot of childTierAnots) {\n          const anotID = getAnnotationID(anot);\n          const startSlot = getAlignableAnnotationStartSlot(anot);\n          const endSlot = getAlignableAnnotationEndSlot(anot);\n          if (startSlot === parentStartSlot && anotID !== childIDs[0]) {\n            childIDs.splice(0, 0, anotID); // insert at beginning\n          } else if (endSlot === parentEndSlot && anotID !== childIDs[childIDs.length - 1]) {\n            childIDs.push(anotID);\n          } \n        }\n        \n        // add children which share a boundary with an existing child\n        // (but not if they end at the first child or start at the last child)\n        let prevIndex = 0;\n        while (prevIndex < childIDs.length - 1) {\n          const prevID = childIDs[prevIndex];\n          const prevAnot = annotationsFromIDs[prevID];\n          const prevSlot = getAlignableAnnotationEndSlot(prevAnot);\n          \n          const nextID = childIDs[prevIndex + 1];\n          const nextAnot = annotationsFromIDs[nextID];\n          const nextSlot = getAlignableAnnotationStartSlot(nextAnot)\n          \n          let newAnot = childTierAnots.find(a => \n            getAlignableAnnotationStartSlot(a) === prevSlot\n          );\n          if (newAnot == null) {\n            newAnot = childTierAnots.find(a =>\n              getAlignableAnnotationEndSlot(a) === nextSlot\n            );\n          }\n          if (newAnot != null) {\n            const newID = getAnnotationID(newAnot);\n            if (newID != null && newID != nextID) {\n              childIDs.splice(prevIndex + 1, 0, newID); // insert after prevIndex\n            }\n          }\n          \n          prevIndex++;\n        }\n        \n        const parentAnotID = getAnnotationID(parentAnot);\n        if (!annotationChildren.hasOwnProperty(parentAnotID)) {\n          annotationChildren[parentAnotID] = {};\n        }\n        annotationChildren[parentAnotID][childTierName] = childIDs;\n      }\n    }\n  }\n  \n  //jsonOut['annotationChildren'] = annotationChildren; // TODO remove when no longer needed for debugging\n  \n  const anotDescendants = {}; // indepAnotID -> depTierName -> ordered listof anotIDs descended from indepAnot\n  for (const indepTier of indepTiers) {\n    for (const indepAnot of getAnnotations(indepTier)) {\n      const indepAnotID = getAnnotationID(indepAnot);\n      const depTiersAnots = {}; // depTierName -> ordered listof anotIDs descended from indepAnot\n      let pendingParentIDs = [indepAnotID];\n      while (pendingParentIDs.length > 0) {\n        const parentID = pendingParentIDs[0];\n        pendingParentIDs.shift() // remove parentID from pendingParentIDs\n        // add all of parentID's direct children to depTierAnots and to pendingParentIDs\n        for (const depTierName in annotationChildren[parentID]) {\n          if (annotationChildren[parentID].hasOwnProperty(depTierName)) {\n            const childIDs = annotationChildren[parentID][depTierName];\n            if (!depTiersAnots.hasOwnProperty(depTierName)) {\n              depTiersAnots[depTierName] = [];\n            }\n            depTiersAnots[depTierName] = depTiersAnots[depTierName].concat(childIDs);\n            pendingParentIDs = pendingParentIDs.concat(childIDs);\n          }\n        }\n      }\n      anotDescendants[indepAnotID] = depTiersAnots;\n    }\n  }\n  //jsonOut['anotDescendants'] = anotDescendants; // TODO remove when no longer needed for debugging\n  \n  const garbageTierNames = pfsxUtils.getHiddenTiers(pfsxIn);\n  let garbageTierIDs = [];\n  for (const garbageTierName of garbageTierNames) {\n    garbageTierIDs.push(tierIDsFromNames[garbageTierName]);\n  }\n  \n  const tierNameOrder = pfsxUtils.getTierOrder(pfsxIn);\n  let tierIDOrder = [];\n  for (const tierName of tierNameOrder) {\n    tierIDOrder.push(tierIDsFromNames[tierName]);\n  }\n  \n  // careful - garbageTierIDs and tierIDOrder may contain undefined, e.g. if there are empty tiers\n  \n  for (let i = 0; i < indepTiers.length; i++) {\n    const spkrID = \"S\" + (i + 1).toString(); // assume each independent tier has a distinct speaker\n    const indepTierName = getTierName(indepTiers[i]);\n    const tierID = tierIDsFromNames[indepTierName];\n    \n    jsonOut.metadata[\"speaker IDs\"][spkrID] = {\n      \"name\": getTierSpeakerName(indepTiers[i]),\n      \"language\": getTierLanguage(indepTiers[i]),\n      \"tier\": tierID,\n    };\n    \n    for (const indepAnot of getAnnotations(indepTiers[i])) {\n      const indepAnotID = getAnnotationID(indepAnot);\n      const anotStartSlots = {};\n      const anotEndSlots = {};\n      assignSlots(indepAnotID, tiersToConstraints, annotationChildren, \n        annotationsFromIDs, timeslots, anotStartSlots, anotEndSlots\n      );\n      \n      const sentenceJson = {\n        \"speaker\": spkrID,\n        \"tier\": tierID,\n        \"start_time_ms\": parseInt(timeslots[getAlignableAnnotationStartSlot(indepAnot)], 10),\n        \"end_time_ms\": parseInt(timeslots[getAlignableAnnotationEndSlot(indepAnot)], 10),\n        \"num_slots\": anotEndSlots[indepAnotID],\n        \"text\": getAnnotationValue(indepAnot),\n        //\"anotID\": indepAnotID, // TODO remove when no longer needed for debugging\n        \"dependents\": [],\n      };\n      \n      const depTiersAnots = anotDescendants[indepAnotID];\n      for (const depTierName in depTiersAnots) {\n        if (depTiersAnots.hasOwnProperty(depTierName)) {\n          const depTierJson = {\n            \"tier\": tierIDsFromNames[depTierName],\n            \"values\": [],\n          };\n          \n          for (const depAnotID of depTiersAnots[depTierName]) {\n            const depAnot = annotationsFromIDs[depAnotID];\n            if (!anotStartSlots.hasOwnProperty(depAnotID)) {\n              console.log(`oh no, missing annotation!`);\n            }\n            depTierJson.values.push({\n              \"start_slot\": anotStartSlots[depAnotID],\n              \"end_slot\": anotEndSlots[depAnotID],\n              //\"anotID\": getAnnotationID(depAnot), // TODO remove when no longer needed for debugging\n              \"value\": getAnnotationValue(depAnot),\n            });\n          }\n          // depTierJson is already in order by start_slot, since anotDescendants is ordered\n          sentenceJson.dependents.push(depTierJson); \n        }\n      }\n      \n      if (tierIDOrder.length !== 0) {\n        const orderedDependents = [];\n        for (const tierID of tierIDOrder) {\n          const tier = sentenceJson.dependents.find((t) => t.tier === tierID);\n          if (tier != null) {\n            orderedDependents.push(tier);\n          }\n        }\n        sentenceJson[\"dependents\"] = orderedDependents;\n      }\n      \n      // remove hidden dependent tiers\n      sentenceJson.dependents = sentenceJson.dependents.filter((t) => !garbageTierIDs.includes(t.tier));\n      // remove the independent tier if it's hidden\n      if (garbageTierIDs.includes(sentenceJson[\"tier\"])) {\n        sentenceJson[\"text\"] = \"\";\n        sentenceJson[\"noTopRow\"] = \"true\";\n      }\n      \n      // sort by the numerical part of the tier ID to ensure consistent ordering; TODO delete this line\n      // sentenceJson.dependents.sort((t1,t2) => parseInt(t1.tier.slice(1),10) - parseInt(t2.tier.slice(1),10));\n          \n      jsonOut.sentences.push(sentenceJson);\n    }\n  }\n  jsonOut.sentences.sort((s1,s2) => s1.start_time_ms - s2.start_time_ms);\n  \n  for (const tier in jsonOut.metadata[\"tier IDs\"]) {\n    if (jsonOut.metadata[\"tier IDs\"].hasOwnProperty(tier) && garbageTierIDs.includes(tier)) {\n      delete jsonOut.metadata[\"tier IDs\"][tier];\n    }\n  }\n  \n  //const jsonPath = jsonFilesDir + storyID + \".json\";\n  //fs.writeFileSync(jsonPath, JSON.stringify(jsonOut, null, 2));\n  fs.writeFile(\"data/eaf_temp.json\", JSON.stringify(jsonOut, null, 2));\n  // fs.readString(\"data/eaf_temp.json\").then((data) => {\n  //   console.log(data)\n  // })\n  // console.log(\"✅  Correctly wrote \" + storyID + \".json\");\n  //callback();\n}\n\n// function preprocess_dir(eafFilesDir, jsonFilesDir, callback) {\n//   const eafFileNames = fs.readdirSync(eafFilesDir).filter(f => \n//     f[0] !== \".\" && f.slice(-4) !== 'pfsx'\n//   ); // excludes pfsx files (which are generated just by opening ELAN) and hidden files\n  \n//   // use this to wait for all preprocess calls to terminate before executing the callback\n//   const status = {numJobs: eafFileNames.length};\n//   if (eafFileNames.length === 0) {\n//     callback();\n//   }\n\n//   const whenDone = function () {\n//     status.numJobs--;\n//     if (status.numJobs <= 0) {\n//       callback();\n//     }\n//   };\n\n//   for (const eafFileName of eafFileNames) {\n//     console.log(\"Processing \" + eafFileName);\n//     const eafPath = eafFilesDir + eafFileName;\n    \n//     // parse .pfsx file, if found\n//     let pfsxJson = null;\n//     let pfsxPath = eafPath.slice(0, -4) + \".pfsx\";\n//     fs.readFile(pfsxPath, function(err1, xmlData) {\n//       if (err1) {\n//         console.log(`WARN: Could not find .pfsx file for ${eafFileName}. Viewing preferences won't be used.`);\n//       } else {\n//         parseXml(xmlData, function (err2, jsonData) {\n//           if (err2) throw err2; \n//           pfsxJson = jsonData;\n//         });\n//       }\n//     });\n    \n//     fs.readFile(eafPath, function (err1, xmlData) {\n//       if (err1) throw err1;\n//       parseXml(xmlData, function (err2, jsonData) {\n//         if (err2) throw err2;\n//         const adoc = jsonData.ANNOTATION_DOCUMENT;\n//         preprocess(adoc, pfsxJson, jsonFilesDir, eafFileName, whenDone);\n//       });\n//     });\n//   }\n// }\n\nmodule.exports = {\n  //preprocess_dir: preprocess_dir,\n  preprocess: preprocess,\n  assignSlots: assignSlots, // TODO remove when no longer needed for debugging\n};\n","/home/kalebe/Projects/laws/src/js/txt_sync.js",[],"/home/kalebe/Projects/laws/src/Stories/Story/Display/Untimed.jsx",[],"/home/kalebe/Projects/laws/src/Stories/Story/Display/Timed.jsx",["150","151","152","153","154","155"],"import id from 'shortid';\nimport { Sentence } from './Sentence.jsx';\nimport { Apagar } from './Apagar.jsx';\n\n\n\nfunction LabeledSentence({ sentence }) {\n\t// I/P: sentence, a sentence\n\t// O/P: glossed sentence with speaker label\n\t// Status: tested, working\n\tconst label = sentence['speaker'];\n\treturn (\n\t\t<div className=\"labeledSentence\">\n\t\t\t<span className=\"speakerLabel\">{label}: </span>\n\t\t\t<Sentence sentence={sentence} isTimeAligned />\n\t\t</div>\n\t);\n}\n\nfunction TimeBlock({ sentences }) {\n\t// I/P: sentences, a list of sentences with the same start time\n\t// O/P: div containing multiple LabeledSentences\n\t// Status: tested, working\n\tlet output = [];\n\t// A timeblock may contain multiple sentences with the same start time.\n\t// Iterate through the list of these sentences.\n\tfor (const sentence of sentences) {\n\t\toutput.push(<LabeledSentence key={id.generate()} sentence={sentence} />);\n\t}\n\treturn <div className=\"timeBlock\">{output}</div>;\n}\n\nfunction printSeconds(r) {\n\t// I/P: an integer number of seconds\n\t// O/P: time interval in h:mm:s or m:ss format (a string)\n\t// Status: tested, working\n\tr=Number(r);var t=Math.floor(r/3600),i=Math.floor(r%3600/60),n=Math.floor(r%3600%60);if(n>=10)e=String(n);else var e=\"0\"+String(n);var o=String(i)+\":\";if(0==t)a=\"\";else if(i>=10)a=String(t)+\":\";else var a=String(t)+\":0\";return a+o+e;\n}\n\nfunction LabeledTimeBlock({ sentences, timestamp }) {\n\t// I/P: sentences, a list of sentences with the same start time\n\t//      timestamp, an integer number of seconds\n\t// O/P: a TimeBlock with a left-floating timestamp\n\t// Status: tested, working\n\ttimestamp = printSeconds(timestamp);\n\t// Return the actual start and end time of this block in ms. Note that end times may differ,\n\t// so take the latest endtime of any sentence in this timeblock. These will be used in attributes\n\t// to render the current block in time with audio/video.\n\tlet minStart = Number.POSITIVE_INFINITY;\n\tlet maxEnd = Number.NEGATIVE_INFINITY;\n\tfor (const sentence of sentences) {\n\t\tconst startTime = sentence[\"start_time_ms\"];\n\t\tconst endTime = sentence[\"end_time_ms\"];\n\t\tif (startTime < minStart) {\n\t\t\tminStart = startTime;\n\t\t}\n\t\tif (endTime > maxEnd) {\n\t\t\tmaxEnd = endTime;\n\t\t}\n\t}\n\t\n\treturn (\n\t\t<div className=\"labeledTimeBlock\" data-start_time={minStart} data-end_time={maxEnd}>\n\t\t\t<span className=\"timeStampContainer\">\n\t\t\t\t<a href=\"javascript:void(0)\" data-start_time={minStart} className=\"timeStamp\">\n\t\t\t\t\t{timestamp}\n\t\t\t\t</a>\n\t\t\t\t<button capture-start-time={minStart} onClick={Apagar}>Delete</button>\n\t\t\t\t\n\t\t\t</span>\n\t\t\t<TimeBlock sentences={sentences} />\n\t\t</div>\n\t);\n}\n\nexport function TimedTextDisplay({ sentences }) {\n\t// I/P: sentences, stored in JSON format, as in test_data.json\n\t// O/P: the main gloss view, with several LabeledTimeBlocks arranged vertically\n\t// Status: tested, working\n\t// Note: very dependent on correct formatting of data\n\tlet output = [];\n\n\t// Steps to create ordered, unique TimeBlocks:\n\t//  1) Create a hashmap from start_times (in sec) to lists of sentences\n\t//  2) Sort the keys of this hashmap (stored in uniqueTimestamps)\n\t//  3) Each key-value pair corresponds to a unique TimeBlock\n\n\tlet timesToSentences = {}; // hashmap from timestamps (in sec) to lists of sentences\n\tlet uniqueTimestamps = []; // for sorting keys\n\tfor (const sentence of sentences) {\n\t\tconst timestampMs = sentence['start_time_ms'];\n\t\tconst timestampSec = Math.floor(timestampMs / 1000); // msec -> sec\n\t\tif (timestampSec in timesToSentences) {\n\t\t\ttimesToSentences[timestampSec].push(sentence);\n\t\t} else {\n\t\t\tuniqueTimestamps.push(timestampSec);\n\t\t\ttimesToSentences[timestampSec] = [sentence];\n\t\t}\n\t}\n\tuniqueTimestamps.sort((a, b) => a - b); // to avoid alphanumeric sorting\n\tfor (const timestamp of uniqueTimestamps) {\n\t\tconst correspondingSentences = timesToSentences[timestamp];\n\t\toutput.push(\n\t\t\t<LabeledTimeBlock \n\t\t\t\tkey={id.generate()} \n\t\t\t\tsentences={correspondingSentences} \n\t\t\t\ttimestamp={timestamp} \n\t\t\t/>\n\t\t);\n\t}\n\t\n\treturn <div id=\"timedTextDisplay\">{output}</div>;\n}","/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Title.jsx",[],"/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Minibar/Minibar.jsx",[],"/home/kalebe/Projects/laws/src/Stories/Story/Display/Apagar.jsx",["156"],"import * as fs from 'fs-web'\nexport function Apagar(){\n    const startTime = window.document.activeElement.getAttribute('capture-start-time');\n    const filho = window.document.activeElement.parentElement.parentElement\n    ApagarElement(filho)\n    ApagarTrilhanoJSON(startTime)\n}\n\nfunction ApagarElement(filho){\n    window.document.activeElement.parentElement.parentElement.parentElement.removeChild(filho)\n}\n\nfunction ApagarTrilhanoJSON(startTime){\n    console.log(startTime)\n    fs.readString('data/eaf_temp.json').then((data) => {\n        \n        let json = JSON.parse(data);\n        let cont=0;\n        let objTemp;\n        json.sentences.forEach(trilha => {\n            cont++;\n            if(trilha['start_time_ms'] == startTime){\n                objTemp = delete json.sentences[cont]\n                if(objTemp){\n                    cont=0;\n                    console.log(json.sentences)\n\n                }\n            }\n        });\n    })\n}","/home/kalebe/Projects/laws/src/Stories/Story/Display/Sentence.jsx",[],"/home/kalebe/Projects/laws/src/preprocessing/pfsx_utils.js",["157"],"/* functions for accessing data within ELAN's .pfsx format (except parsed to JSON).\nThe functions return reasonable results even when the parse of the .pfsx file is null,\nto allow for use even if the pfsx file is missing from data/elan_files\nor even if the pfsx file failed to parse. */\n\nfunction getPrefList(listName, jsonData) {\n  if (jsonData == null || jsonData['preferences'] == null || jsonData['preferences']['prefList'] == null) {\n    // jsonData==null or jsonData['preferences']==null means there wasn't a valid pfsx file.\n    // jsonData['preferences']['prefList']==null means there are e.g. tier color preferences, \n    //     but all the list-type preferences are still set to the defaults.\n    \n    return [];\n  }\n  let prefLists = jsonData['preferences']['prefList'];\n  for (let prefList of prefLists) {\n    if (prefList['$'] == null) {\n      // this shouldn't happen, but just skip this prefList and move to the next one \n      continue;\n    }\n    if (prefList['$']['key'] == listName) {\n      \n      return prefList['String'] || []; // assume all prefLists are lists of strings\n    }\n  }\n  \n  return [];\n}\n\nfunction getTierOrder(jsonData) {\n  return getPrefList('MultiTierViewer.TierOrder', jsonData);\n}\n\nfunction getHiddenTiers(jsonData) {\n  return getPrefList('MultiTierViewer.HiddenTiers', jsonData) || [];\n}\n\nmodule.exports = {\n  getTierOrder : getTierOrder,\n  getHiddenTiers : getHiddenTiers,\n}","/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Minibar/Info/Info.jsx",[],"/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Minibar/Settings/Settings.jsx",[],"/home/kalebe/Projects/laws/src/preprocessing/eaf_utils.js",["158"],"/* functions for accessing data within ELAN's format (except parsed to JSON): */\n\n// adoc - an annotation document\n// returns the hexadecimal code from the URN, or null if none was found\nfunction getDocID(adoc) {\n  const properties = adoc.HEADER[0].PROPERTY;\n  for (const property of properties) {\n    if (property.$.NAME === 'URN') {\n      const urn = property._;\n      return urn.substring(urn.lastIndexOf(':') + 1);\n    }\n  }\n  return null;\n}\n\n// adoc - an annotation document\n// returns a map from each timeslotID to its time value in ms\nfunction getDocTimeslotsMap(adoc) {\n  const timeslotsIn = adoc.TIME_ORDER[0].TIME_SLOT;\n  if (timeslotsIn == null) { // this happens on newly created ELAN files\n    console.log(\"WARN: No timing information found. It looks like this ELAN file doesn't have any annotations.\");\n    return {};\n  }\n  let timeslots = [];\n  for (const slot of timeslotsIn) {\n    timeslots[slot.$.TIME_SLOT_ID] = parseInt(slot.$.TIME_VALUE, 10);\n  }\n  return timeslots;\n}\n\n// adoc - an annotation document\n// returns a list of tiers (JSON objects)\nfunction getNonemptyTiers(adoc) {\n  const allTiers = adoc.TIER;\n  return allTiers.filter((tier) =>\n      tier.ANNOTATION != null && tier.ANNOTATION.length > 0\n  );\n}\n\n// returns a map: tier name -> list of tier names of its children\nfunction getTierChildrenMap(tiers) {\n  const tierChildren = {};\n  for (const tier of tiers) {\n    const parentName = getParentTierName(tier);\n    if (parentName != null) {\n      if (tierChildren[parentName] == null) {\n        tierChildren[parentName] = [];\n      }\n      tierChildren[parentName].push(getTierName(tier));\n    }\n  }\n  return tierChildren;\n}\n\n// `children` should be a lookup table from each element to its list of children\nfunction getDescendants(ancestor, children) { // not including ancestor itself\n  if (children[ancestor] == null) {\n    return [];\n  }\n  let descendants = children[ancestor];\n  for (const child of children[ancestor]) {\n    descendants = descendants.concat(getDescendants(child, children));\n  }\n  return descendants;\n}\n\n// return a map from indep tier name to list of dep tier names\nfunction getTierDependentsMap(tiers) {\n  const indepTiers = tiers.filter((tier) => getParentTierName(tier) == null);\n  const tierChildren = getTierChildrenMap(tiers);\n  let tierDependents = {};\n  for (const indepTier of indepTiers) {\n    const indepTierName = getTierName(indepTier);\n    tierDependents[indepTierName] = getDescendants(indepTierName, tierChildren);\n  }\n  return tierDependents;\n}\n\nfunction getAnnotationIDMap(tiers) {\n  const annotationsFromIDs = {};\n  for (const tier of tiers) {\n    for (const annotation of getAnnotations(tier)) {\n      const annotationID = getInnerAnnotationID(unwrapAnnotation(annotation));\n      annotationsFromIDs[annotationID] = annotation;\n    }\n  }\n  return annotationsFromIDs;\n}\n\n// comparison function for timeslot IDs\nfunction slotIDDiff(slot1, slot2) {\n  return parseInt(slot1.slice(2)) - parseInt(slot2.slice(2));\n}\n\n/* return a map: independent_tier_id -> timeslot_id -> rank,\n  where a timeslot's \"rank\" is what its index would be\n  in a time-ordered array of the unique timeslots for this speaker */\nfunction getTierTimeslotsMap(tiers) {\n  const indepTiers = tiers.filter((tier) => getParentTierName(tier) == null);\n  const tierDependents = getTierDependentsMap(tiers);\n  const tierTimeslots = {};\n  for (const indepTier of indepTiers) {\n    const indepTierName = getTierName(indepTier);\n\n    let slotsSet = getTimeslotSet(indepTier); // use a set to omit duplicates\n    for (const maybeDepTier of tiers) {\n      if (tierDependents[indepTierName].includes(getTierName(maybeDepTier))) {\n        // maybeDepTier is a dependent of indepTier\n        for (const slot of getTimeslotSet(maybeDepTier)) {\n          slotsSet.add(slot);\n        }\n      }\n    }\n    const slotsArray = Array.from(slotsSet);\n\n    // sort by the numerical part of the timeslot ID\n    const sortedSlots = slotsArray.sort(slotIDDiff);\n\n    // create a map from timeslot ID to its \"rank\" (its position in the sorted array)\n    let slotRanks = {};\n    for (const slotIndex in sortedSlots) {\n      if (sortedSlots.hasOwnProperty(slotIndex)) {\n        slotRanks[sortedSlots[slotIndex]] = slotIndex;\n      }\n    }\n    tierTimeslots[indepTierName] = slotRanks;\n  }\n  return tierTimeslots;\n}\n\n// return true if tier has alignable annotations, false if it has ref annotations\nfunction isTierAlignable(tier) {\n  return getAnnotations(tier)[0].ALIGNABLE_ANNOTATION != null;\n}\n\nfunction isTierSubdivided(tierName, tiers) { // true iff tierName has a dependent, aligned ancestor tier\n  return getParentTierName(getTierAlignedAncestor(tierName, tiers)) != null;\n}\n\nfunction getTierAlignedAncestor(tierName, tiers) {\n  let currentTier = tiers.find(tier => getTierName(tier) === tierName);\n  while (!isTierAlignable(currentTier)) {\n    currentTier = tiers.find(tier => getTierName(tier) === getParentTierName(currentTier));\n  }\n  return currentTier;\n}\n\n// returns the ELAN-user-specified tier name (string)\nfunction getTierName(tier) {\n  return tier.$.TIER_ID;\n}\n\n// returns the ELAN-user-specified name of its parent-tier (string), or null if tier is independent\nfunction getParentTierName(tier) {\n  return tier.$.PARENT_REF;\n}\n\n// returns the ELAN-user-specified speaker's name (string or null)\nfunction getTierSpeakerName(tier) {\n  return tier.$.PARTICIPANT;\n}\n\n// returns the tier's language (a string), which is often an ISO code\nfunction getTierLanguage(tier) {\n  return tier.$.LANG_REF;\n}\n\nfunction getAnnotations(tier) {\n  return tier.ANNOTATION;\n}\n\n// return the set of timeslotIDs referenced in this tier\nfunction getTimeslotSet(tier) {\n  if (!isTierAlignable(tier)) {\n    // no timestamps in this tier; it's all REF_ANNOTATIONs\n    return new Set();\n  }\n  const annotations = getAnnotations(tier);\n  const startSlots = new Set(annotations.map((a) => getAlignableAnnotationStartSlot(a)));\n  const endSlots = new Set(annotations.map((a) => getAlignableAnnotationEndSlot(a)));\n  let allSlots = startSlots;\n  for (const slot of endSlots) {\n    allSlots.add(slot);\n  }\n  return allSlots;\n}\n\nfunction isAnnotationAlignable(annotation) {\n  return annotation.ALIGNABLE_ANNOTATION != null;\n}\n\nfunction unwrapAnnotation(annotation) {\n  if (isAnnotationAlignable(annotation)) {\n    return annotation.ALIGNABLE_ANNOTATION[0];\n  } else {\n    return annotation.REF_ANNOTATION[0];\n  }\n}\n\nfunction getAnnotationID(annotation) {\n  return getInnerAnnotationID(unwrapAnnotation(annotation));\n}\n\nfunction getAnnotationValue(annotation) {\n  return getInnerAnnotationValue(unwrapAnnotation(annotation));\n}\n\n// returns an annotation with the same start and end timeslots as this annotation\nfunction getAnnotationTimedAncestor(annotation, annotationsFromIDs) {\n  let currentannotation = annotation;\n  while (currentannotation.ALIGNABLE_ANNOTATION == null) {\n    const parentAnnotationID = currentannotation.REF_ANNOTATION[0].$.ANNOTATION_REF;\n    currentannotation = annotationsFromIDs[parentAnnotationID];\n  }\n  return currentannotation;\n}\n\nfunction getAnnotationStartSlot(annotation, annotationsFromIDs) {\n  return getInnerAnnotationStartSlot(unwrapAnnotation(getAnnotationTimedAncestor(annotation, annotationsFromIDs)));\n}\n\nfunction getAnnotationEndSlot(annotation, annotationsFromIDs) {\n  return getInnerAnnotationEndSlot(unwrapAnnotation(getAnnotationTimedAncestor(annotation, annotationsFromIDs)));\n}\n\nfunction getAlignableAnnotationStartSlot(annotation) {\n  return getInnerAnnotationStartSlot(unwrapAnnotation(annotation));\n}\n\nfunction getAlignableAnnotationEndSlot(annotation) {\n  return getInnerAnnotationEndSlot(unwrapAnnotation(annotation));\n}\n\nfunction getInnerAnnotationID(innerAnnotation) {\n  return innerAnnotation.$.ANNOTATION_ID;\n}\n\nfunction getInnerAnnotationValue(innerAnnotation) {\n  return innerAnnotation.ANNOTATION_VALUE[0];\n}\n\nfunction getInnerAnnotationStartSlot(innerAnnotation) {\n  return innerAnnotation.$.TIME_SLOT_REF1;\n}\n\nfunction getInnerAnnotationEndSlot(innerAnnotation) {\n  return innerAnnotation.$.TIME_SLOT_REF2;\n}\n\nmodule.exports = {\n  getDocID: getDocID,\n  getDocTimeslotsMap: getDocTimeslotsMap,\n  getNonemptyTiers: getNonemptyTiers,\n  getTierChildrenMap: getTierChildrenMap,\n  getTierDependentsMap: getTierDependentsMap,\n  getAnnotationIDMap: getAnnotationIDMap,\n  slotIDDiff: slotIDDiff,\n  // getTierNamesMap: getTierNamesMap,\n  getTierTimeslotsMap: getTierTimeslotsMap,\n\n  // isTierAlignable: isTierAlignable,\n  isTierSubdivided: isTierSubdivided,\n  // getTierAlignedAncestor: getTierAlignedAncestor,\n  getTierName: getTierName,\n  getParentTierName: getParentTierName,\n  getTierSpeakerName: getTierSpeakerName,\n  getTierLanguage: getTierLanguage,\n  getAnnotations: getAnnotations,\n  // getTimeslotSet: getTimeslotSet,\n\n  isAnnotationAlignable: isAnnotationAlignable,\n  // unwrapAnnotation: unwrapAnnotation,\n  getAnnotationID: getAnnotationID,\n  getAnnotationValue: getAnnotationValue,\n  // getAnnotationTimedAncestor: getAnnotationTimedAncestor,\n  getAnnotationStartSlot: getAnnotationStartSlot,\n  getAnnotationEndSlot: getAnnotationEndSlot,\n  getAlignableAnnotationStartSlot: getAlignableAnnotationStartSlot,\n  getAlignableAnnotationEndSlot: getAlignableAnnotationEndSlot,\n\n  // getInnerAnnotationValue: getInnerAnnotationValue,\n  // getInnerAnnotationStartSlot: getInnerAnnotationStartSlot,\n  // getInnerAnnotationEndSlot: getInnerAnnotationEndSlot,\n};","/home/kalebe/Projects/laws/src/preprocessing/helper_functions.js",["159","160","161"],"const fs = require('fs');\nconst flexUtils = require('./flex_utils'); // TODO use me more, and use eafUtils too, for stylistic consistency\n\nfunction getMetadataFromIndex(filename) {\n  // I/P: filename, an XML or EAF file\n  // O/P: a JSON object with metadata for the given file;\n  //      or null if filename not in index\n  // Status: tested, working\n  const index = JSON.parse(fs.readFileSync(\"data/index.json\", \"utf8\"));\n  if (index.hasOwnProperty(filename)) {\n    return index[filename];\n  } else {\n    return null;\n  }\n}\n\nfunction getFilenameFromPath(path) {\n  // I/P: path, a string\n  // O/P: the filename which occurs at the end of the path\n  // Status: untested\n  const begin = String(path).lastIndexOf(\"/\") + 1; // @Kalinda, this might fail on windows.\n  return String(path).substring(begin, path.length);\n}\n\nfunction getFlexMediaFilenames(itext) {\n  let filenames = [];\n  const mediaFiles = itext[\"media-files\"];\n  if (mediaFiles != null) {\n    const mediaList = mediaFiles[0].media;\n    for (const media of mediaList) {\n      filenames.push(media.$.location);\n    }\n  }\n  return filenames;\n}\n\nfunction verifyMedia(filename) {\n  // I/P: filename, a .mp3 or .mp4 file\n  // O/P: boolean, whether or not file exists in media_files directory\n  // Status: untested\n  // const media_files = fs.readdirSync(\"data/media_files\");\n  // return (media_files.indexOf(filename) >= 0);\n  return \"\"\n}\n\nfunction findValidMedia(filenames) {\n  // I/P: filenames, a list of filenames (file extension included) that would be considered a match\n  // O/P: the first filename in the list that we can use as media, or null if none was found\n  for (const mediaFilename of filenames) {\n    if (verifyMedia(mediaFilename)) {\n      return mediaFilename;\n    }\n  }\n  return null;\n}\n\nfunction mediaSearch(filename, mediaType, mediaFiles, extension) {\n  // I/P: filename, the name of the ELAN or FLEx file\n  // I/P: mediaType, which is either \"video\" or \"audio\", for printing to the command line\n  // I/P: mediaFiles, a list of the media files that were linked in the ELAN or FLEx file\n  // I/P: extension, file extension for media files, including the leading period\n  // O/P: the filename of the first valid media that was found, or null if none exists\n  console.log(\"🚨  WARN: \" + filename + \" is missing correctly linked \" + mediaType + \". Attemping to find link...\");\n  const shortFilename = String(filename).substring(0, String(filename).lastIndexOf('.'));\n  const shortestFilename = String(filename).substring(0, filename.indexOf('.')); // more possible matches for .postflex.flextext files\n  const filenamesToTry = mediaFiles.concat([shortFilename + extension, shortestFilename + extension]);\n  const mediaFile = findValidMedia(filenamesToTry);\n  if (mediaFile != null) {\n    console.log(\"🔍  SUCCESS: Found matching \" + mediaType + \": \" + mediaFile);\n  } else {\n    console.log(\"❌  ERROR: Cannot find matching \" + mediaType + \" for \" + shortFilename + \". \");\n  }\n  return mediaFile;\n}\n\nfunction updateMediaMetadata(filename, storyID, metadata, linkedMediaPaths) {\n  // Only call this function if the file contains timestamps.\n  // I/P: filename, of the FLEx or ELAN file\n  // I/P: storyId, the unique ID of this document\n  // I/P: metadata, a json object formatted for use on the site\n  // I/P: linkedMediaPaths, a list of media file paths mentioned in the FLEx or ELAN file \n  // O/P: updates metadata by filling in any missing audio/video file names, if we can,\n  //  and setting timed=false if we can't find any audio/video files\n  \n  metadata['timed'] = true;\n\n  const audioFile = metadata['media']['audio'];\n  let hasWorkingAudio = verifyMedia(audioFile);\n  if (!hasWorkingAudio) {\n    metadata['media']['audio'] = \"\";\n  }\n  const videoFile = metadata['media']['video'];\n  let hasWorkingVideo = verifyMedia(videoFile);\n  if (!hasWorkingVideo) {\n    metadata['media']['video'] = \"\";\n  }\n\n  // If both audio/video work, then we're done. Otherwise, figure out what we need.\n  if (hasWorkingAudio && hasWorkingVideo) {\n    return;\n  }\n  let needsAudio = false;\n  let needsVideo = false;\n  let audioFiles = [];\n  let videoFiles = [];\n  for (const mediaPath of linkedMediaPaths) {\n    const mediaFilename = getFilenameFromPath(mediaPath);\n    const fileExtension = String(mediaFilename).substring(String(mediaFilename).lastIndexOf('.')).toLowerCase();\n    if (fileExtension === '.mp3' || fileExtension === '.wav') {\n      audioFiles.push(mediaFilename);\n      needsAudio = true;\n    } else if (fileExtension === '.mp4') {\n      videoFiles.push(mediaFilename);\n      needsVideo = true;\n    }\n  }\n  \n  // Media search\n  if (needsAudio && !hasWorkingAudio) {\n    const audioFile = mediaSearch(filename, \"audio\", audioFiles, \".mp3\");\n    if (audioFile != null) {\n      hasWorkingAudio = true;\n      metadata['media']['audio'] = audioFile;\n    }\n  }\n  if (needsVideo && !hasWorkingVideo) {\n    const videoFile = mediaSearch(filename, \"video\", videoFiles, \".mp4\");\n    if (videoFile != null) {\n      hasWorkingVideo = true;\n      metadata['media']['video'] = videoFile;\n    }\n  }\n  \n  // Worst case scenario: no media\n  if (!hasWorkingAudio && !hasWorkingVideo) {\n    metadata['timed'] = false;\n    console.log(\"❌  ERROR: \" + filename + \" (unique ID: \" + storyID + \") has no linked audio or video in the media_files directory. It will be processed as an untimed file and no audio, video, or time alignment will be displayed on the site.\");\n  }\n}\n\nfunction getTitleFromFilename(filename) {\n  return String(filename).substring(0, String(filename).lastIndexOf('.'));\n}\n\n// function improveFLExIndexData(path, storyID, itext) {\n//   // I/P: path, a string\n//   //      itext, an interlinear text, e.g., jsonIn[\"document\"][\"interlinear-text\"][0]\n//   // O/P: a JSON object, based on the index.json file and new metadata\n//   // Status: untested\n//   let metadata = getMetadataFromIndex(storyID);\n\n//   const date = new Date();\n//   const prettyDate = (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();\n  \n//   const hasTimestamps = flexUtils.documentHasTimestamps(itext);\n  \n//   // get title/source info, part 1\n//   let titlesAndSources = itext[\"item\"];\n//   let titles = {};\n//   let sources = {};\n//   if (titlesAndSources != null) {\n//     for (const current_title of titlesAndSources) {\n//       if (current_title['$']['type'] === 'title') {\n//         titles[(current_title[\"$\"][\"lang\"])] = current_title[\"_\"];\n//       } else if (current_title['$']['type'] === 'source') {\n//         sources[(current_title[\"$\"][\"lang\"])] = current_title[\"_\"];\n//       }\n//     }\n//   }\n  \n//   if (metadata == null) { // file not in index previously\n  \n//     let defaultTitle = getTitleFromFilename(getFilenameFromPath(path));\n//     // Uncomment the three lines below to use a particular language title \n//     // (in this case \"es\", Spanish) as the main title for newly added documents. \n//     // if (titles[\"es\"] != null && titles[\"es\"] != \"\") {\n//       // defaultTitle = titles[\"es\"];\n//     // }\n  \n//     // below is the starter data:\n//     metadata = {\n//       \"timed\": hasTimestamps,\n//       \"story ID\": storyID,\n//       \"title\": {\n//         \"_default\": defaultTitle,\n//       },\n//       \"media\": {\n//         \"audio\": \"\",\n//         \"video\": \"\"\n//       },\n//       \"languages\": [],\n//       \"date_created\": \"\",\n//       \"date_uploaded\": prettyDate,\n//       \"source\": {\n//         \"_default\": \"\"\n//       },\n//       \"description\": \"\",\n//       \"genre\": \"\",\n//       \"author\": \"\",\n//       \"glosser\": \"\",\n//       \"speakers\": [],\n//       \"xml_file_name\": path,\n//       \"source_filetype\": \"FLEx\"\n//     }\n//   }\n  \n//   // get title/source info, part 2\n//   titles[\"_default\"] = metadata[\"title\"][\"_default\"];\n//   sources[\"_default\"] = metadata[\"source\"][\"_default\"];\n//   metadata[\"title\"] = titles;\n//   metadata[\"source\"] = sources;\n  \n//   // get language info\n//   let languages = [];\n//   let itextLanguages = itext.languages;\n//   if (itextLanguages != null) { // null on .flextext freshly exported from ELAN\n//     const languageData = itextLanguages[0].language;\n//     for (const language of languageData) {\n//       languages.push(language[\"$\"][\"lang\"]);\n//     }\n//   }\n//   metadata[\"languages\"] = languages;\n  \n//   // fill in any missing audio/video files, if we can\n//   const linkedMediaPaths = getFlexMediaFilenames(itext);\n//   const filename = getFilenameFromPath(path);\n//   if (hasTimestamps) {\n//     updateMediaMetadata(filename, storyID, metadata, linkedMediaPaths);\n//   }\n  \n//   return metadata;\n// }\n\nfunction improveElanIndexData(path, storyID, adoc) {\n  // I/P: path, a string\n  //      storyID, a string\n  //      adoc, an annotation document\n  // O/P: a JSON object, based on the index.json file and new metadata\n  // Status: untested\n  const filename = getFilenameFromPath(path);\n  //let metadata = getMetadataFromIndex(storyID);\n  let metadata = null;\n\n  const date = new Date();\n  const prettyDate = (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();\n\n  if (metadata == null) { // file not in index previously\n    // below is the starter data:\n    metadata = {\n      \"timed\": true,\n      \"story ID\": storyID,\n      \"title\": {\n        \"_default\": getTitleFromFilename(filename),\n      },\n      \"media\": {\n        \"audio\": \"\",\n        \"video\": \"\"\n      },\n      \"languages\": [],\n      \"date_created\": \"\",\n      \"date_uploaded\": prettyDate,\n      \"source\": {\n        \"_default\": \"\"\n      },\n      \"description\": \"\",\n      \"genre\": \"\",\n      \"author\": \"\",\n      \"glosser\": \"\",\n      \"speakers\": [],\n      \"xml_file_name\": path,\n      \"source_filetype\": \"ELAN\"\n    };\n  }\n\n  // get language info\n  let speakers = new Set(); // to avoid duplicates\n  const tiers = adoc['TIER'];\n  for (const tier of tiers) {\n    if (tier['$']['PARTICIPANT']) {\n      speakers.add(tier['$']['PARTICIPANT']);\n    }\n  }\n  metadata['speakers'] = Array.from(speakers);\n\n  // fill in any missing audio/video files, if we can\n  let linkedMediaPaths = [];\n  let mediaDescriptors = adoc['HEADER'][0]['MEDIA_DESCRIPTOR'];\n  if (mediaDescriptors != null) { // null happens on ELAN->FLEx->ELAN files\n    for (const mediaDesc of mediaDescriptors) {\n      linkedMediaPaths.push(mediaDesc['$']['MEDIA_URL']);\n    }\n  }\n  //updateMediaMetadata(filename, storyID, metadata, linkedMediaPaths)\n\n  return metadata;\n}\n\nmodule.exports = {\n  //verifyMedia: verifyMedia,\n  getMetadataFromIndex: getMetadataFromIndex,\n  getFilenameFromPath: getFilenameFromPath,\n  //improveFLExIndexData: improveFLExIndexData,\n  improveElanIndexData: improveElanIndexData\n};\n","/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Minibar/Info/Metadata.jsx",["162","163","164","165","166","167","168","169","170"],"export function Metadata({ metadata }) {\n\t// I/P: metadata, in JSON format\n\t// O/P: a nice display of speaker names + other metadata\n\t// Status: finished\n\tlet description = null;\n\tlet author = null;\n\tlet genre = null;\n\tlet date_created = null;\n\n\tif (metadata[\"description\"] != \"\") {\n\t\tdescription = <p><b>Description:</b> {metadata[\"description\"]}</p>;\n\t}\n\n\tif (metadata[\"author\"] != \"\") {\n\t\tauthor = <p>Author: {metadata[\"author\"]}</p>;\n\t}\n\n\tif (metadata[\"genre\"] != \"\") {\n\t\tgenre = <p>Genre: {metadata[\"genre\"]}</p>;\n\t}\n\n\tif (metadata[\"date_created\"] != \"\") {\n\t\tdate_created = <p>Date: {metadata[\"date_created\"]}</p>;\n\t}\n\n\treturn (\n\t\t<div id=\"metadata\">\n\t\t\t{description}\n\t\t\t{author}\n\t\t</div>\n\t);\n}\n\nexport function MoreMetadata({ metadata }) {\n\t// I/P: metadata, in JSON format\n\t// O/P: glosser + source information\n\t// Status: finished\n\tlet glosser = null;\n\tlet source = null;\n\n\n\tif (metadata[\"glosser\"] != \"\") {\n\t\tglosser = <p>Glosser: {metadata[\"glosser\"]}</p>;\n\t}\n\n\tif (metadata[\"source\"][\"_default\"] != \"\") {\n\t\tsource = <p>Source: {metadata[\"source\"][\"_default\"]}</p>;\n\t} else if (metadata[\"source\"].hasOwnProperty(\"con-Latn-EC\") && metadata[\"source\"][\"con-Latn-EC\"] != \"\") {\n\t\tsource = <p>Source: {metadata[\"source\"][\"con-Latn-EC\"]}</p>;\n\t}\n\n\treturn (\n\t\t<div id=\"metadata\">\n\t\t\t{source}\n\t\t\t{glosser}\n\t\t</div>\n\t);\n}","/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Minibar/Info/SpeakerInfo.jsx",[],"/home/kalebe/Projects/laws/src/Stories/Story/Sidebar/Minibar/Settings/TierCheckboxList.jsx",["171"],"import React from 'react'\nimport $ from 'jquery'\nclass TierCheckbox extends React.Component {\n   // I/P: tier_id, a string like \"T1\" or \"T15\"\n   //    tier_name, a string like \"English Morphemes\"\n   // O/P: a checkbox with the ability to hide/show elements with tier-data={tier_id}\n   // Status: tested, working\n   constructor(props) {\n      super(props);\n      this.state = {\n         checkboxState: true\n      };\n      this.toggle = this.toggle.bind(this);\n   }\n\n   toggle(event) {\n      this.setState({checkboxState: !this.state.checkboxState});\n\n      if (this.state.checkboxState) {\n         $(\"tr[data-tier='\" + this.props.tier_id + \"']\").css('display', 'none');\n      } else {\n         $(\"tr[data-tier='\" + this.props.tier_id + \"']\").css('display', 'table-row');\n      }\n   }\n\n   render() {\n      const tier_id = this.props.tier_id;\n      const tier_name = this.props.tier_name;\n      return (\n         <li>\n            <input type=\"checkbox\" onClick={this.toggle} defaultChecked />\n            <label>{tier_name}</label>\n         </li>\n      );\n   }\n}\n\nexport function TierCheckboxList({ tiers }) {\n   // I/P: tiers, a hashmap from Tier IDs to their names\n   // O/P: an unordered list of TierCheckboxes\n   // Status: tested, working\n   let output = [];\n   for (const tier_id in tiers) {\n      if (tiers.hasOwnProperty(tier_id)) {\n         output.push(<TierCheckbox key={tier_id} tier_id={tier_id} tier_name={tiers[tier_id]['name']} />);\n      }\n   }\n   return <div id=\"tierList\"><b>Show/hide tiers:</b> <ul>{output}</ul></div>;\n}","/home/kalebe/Projects/laws/src/preprocessing/flex_utils.js",[],["172","173"],{"ruleId":"174","replacedBy":"175"},{"ruleId":"176","replacedBy":"177"},{"ruleId":"178","severity":1,"message":"179","line":5,"column":5,"nodeType":"180","messageId":"181","endLine":7,"endColumn":6},{"ruleId":"182","severity":1,"message":"183","line":2,"column":13,"nodeType":"184","messageId":"185","endLine":2,"endColumn":15},{"ruleId":"186","severity":1,"message":"187","line":57,"column":17,"nodeType":"188","messageId":"189","endLine":57,"endColumn":24},{"ruleId":"190","severity":1,"message":"191","line":115,"column":101,"nodeType":"192","endLine":115,"endColumn":113},{"ruleId":"178","severity":1,"message":"179","line":4,"column":5,"nodeType":"180","messageId":"181","endLine":6,"endColumn":6},{"ruleId":"193","severity":1,"message":"194","line":11,"column":36,"nodeType":"195","messageId":"189","endLine":11,"endColumn":38},{"ruleId":"193","severity":1,"message":"194","line":15,"column":54,"nodeType":"195","messageId":"189","endLine":15,"endColumn":56},{"ruleId":"182","severity":1,"message":"196","line":194,"column":22,"nodeType":"184","messageId":"185","endLine":194,"endColumn":24},{"ruleId":"197","severity":1,"message":"198","line":195,"column":39,"nodeType":"199","messageId":"200","endLine":196,"endColumn":93},{"ruleId":"197","severity":1,"message":"201","line":238,"column":43,"nodeType":"199","messageId":"200","endLine":242,"endColumn":14},{"ruleId":"182","severity":1,"message":"202","line":266,"column":11,"nodeType":"184","messageId":"185","endLine":266,"endColumn":25},{"ruleId":"193","severity":1,"message":"194","line":355,"column":40,"nodeType":"195","messageId":"189","endLine":355,"endColumn":42},{"ruleId":"203","severity":1,"message":"204","line":37,"column":96,"nodeType":"184","messageId":"205","endLine":37,"endColumn":97},{"ruleId":"193","severity":1,"message":"206","line":37,"column":157,"nodeType":"195","messageId":"189","endLine":37,"endColumn":159},{"ruleId":"203","severity":1,"message":"207","line":37,"column":161,"nodeType":"184","messageId":"205","endLine":37,"endColumn":162},{"ruleId":"203","severity":1,"message":"207","line":37,"column":180,"nodeType":"184","messageId":"205","endLine":37,"endColumn":181},{"ruleId":"208","severity":1,"message":"209","line":65,"column":5,"nodeType":"210","endLine":65,"endColumn":83},{"ruleId":"211","severity":1,"message":"212","line":65,"column":13,"nodeType":"213","messageId":"214","endLine":65,"endColumn":33},{"ruleId":"193","severity":1,"message":"206","line":22,"column":40,"nodeType":"195","messageId":"189","endLine":22,"endColumn":42},{"ruleId":"193","severity":1,"message":"206","line":20,"column":30,"nodeType":"195","messageId":"189","endLine":20,"endColumn":32},{"ruleId":"197","severity":1,"message":"215","line":143,"column":30,"nodeType":"199","messageId":"200","endLine":143,"endColumn":90},{"ruleId":"182","severity":1,"message":"216","line":2,"column":7,"nodeType":"184","messageId":"185","endLine":2,"endColumn":16},{"ruleId":"182","severity":1,"message":"217","line":25,"column":10,"nodeType":"184","messageId":"185","endLine":25,"endColumn":31},{"ruleId":"182","severity":1,"message":"218","line":76,"column":10,"nodeType":"184","messageId":"185","endLine":76,"endColumn":29},{"ruleId":"193","severity":1,"message":"194","line":10,"column":30,"nodeType":"195","messageId":"189","endLine":10,"endColumn":32},{"ruleId":"193","severity":1,"message":"194","line":14,"column":25,"nodeType":"195","messageId":"189","endLine":14,"endColumn":27},{"ruleId":"193","severity":1,"message":"194","line":18,"column":24,"nodeType":"195","messageId":"189","endLine":18,"endColumn":26},{"ruleId":"182","severity":1,"message":"219","line":19,"column":3,"nodeType":"184","messageId":"185","endLine":19,"endColumn":8},{"ruleId":"193","severity":1,"message":"194","line":22,"column":31,"nodeType":"195","messageId":"189","endLine":22,"endColumn":33},{"ruleId":"182","severity":1,"message":"220","line":23,"column":3,"nodeType":"184","messageId":"185","endLine":23,"endColumn":15},{"ruleId":"193","severity":1,"message":"194","line":42,"column":26,"nodeType":"195","messageId":"189","endLine":42,"endColumn":28},{"ruleId":"193","severity":1,"message":"194","line":46,"column":37,"nodeType":"195","messageId":"189","endLine":46,"endColumn":39},{"ruleId":"193","severity":1,"message":"194","line":48,"column":99,"nodeType":"195","messageId":"189","endLine":48,"endColumn":101},{"ruleId":"182","severity":1,"message":"221","line":27,"column":13,"nodeType":"184","messageId":"185","endLine":27,"endColumn":20},{"ruleId":"174","replacedBy":"222"},{"ruleId":"176","replacedBy":"223"},"no-native-reassign",["224"],"no-negated-in-lhs",["225"],"no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","no-unused-vars","'fs' is defined but never used.","Identifier","unusedVar","no-dupe-keys","Duplicate key 'timed'.","ObjectExpression","unexpected","react/jsx-no-duplicate-props","No duplicate props allowed","JSXAttribute","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","'id' is assigned a value but never used.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'prev'.","ArrowFunctionExpression","unsafeRefs","Function declared in a loop contains unsafe references to variable(s) 'prevSlot', 'prevSlot', 'prevSlot'.","'parentTierName' is assigned a value but never used.","no-use-before-define","'e' was used before it was defined.","usedBeforeDefined","Expected '===' and instead saw '=='.","'a' was used before it was defined.","jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","no-script-url","Script URL is a form of eval.","Literal","unexpectedScriptURL","Function declared in a loop contains unsafe references to variable(s) 'currentTier'.","'flexUtils' is assigned a value but never used.","'getFlexMediaFilenames' is defined but never used.","'updateMediaMetadata' is defined but never used.","'genre' is assigned a value but never used.","'date_created' is assigned a value but never used.","'tier_id' is assigned a value but never used.",["224"],["225"],"no-global-assign","no-unsafe-negation"]